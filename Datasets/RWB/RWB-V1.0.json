{
    "Cli-251": {
        "buggy": "    private boolean isJavaProperty(final String token) {\n        final String opt = token.substring(0, 1);\n        final Option option = options.getOption(opt);\n\n        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n    }",
        "fix": "    private boolean isJavaProperty(final String token) {\n        final String opt = token.isEmpty() ? null : token.substring(0, 1);\n        final Option option = options.getOption(opt);\n\n        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n    }",
        "start": 582,
        "end": 587,
        "location": [
            583
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/cli/DefaultParser.java"
    },
    "Cli-253": {
        "buggy": "    private boolean isJavaProperty(final String token) {\n        final String opt = token.substring(0, 1);\n        final Option option = options.getOption(opt);\n\n        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n    }",
        "fix": "    private boolean isJavaProperty(final String token) {\n        final String opt = token.isEmpty() ? null : token.substring(0, 1);\n        final Option option = options.getOption(opt);\n\n        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n    }",
        "start": 582,
        "end": 587,
        "location": [
            583
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/cli/DefaultParser.java"
    },
    "Cli-254": {
        "buggy": "    private boolean isJavaProperty(final String token) {\n        final String opt = token.substring(0, 1);\n        final Option option = options.getOption(opt);\n\n        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n    }",
        "fix": "    private boolean isJavaProperty(final String token) {\n        final String opt = token.isEmpty() ? null : token.substring(0, 1);\n        final Option option = options.getOption(opt);\n\n        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n    }",
        "start": 582,
        "end": 587,
        "location": [
            583
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/cli/DefaultParser.java"
    },
    "Cli-257": {
        "buggy": "    private void checkRequiredArgs() throws ParseException {\n        if (currentOption != null && currentOption.requiresArg()) {\n            throw new MissingArgumentException(currentOption);\n        }\n    }",
        "fix": "    private void checkRequiredArgs() throws ParseException {\n        if (currentOption != null && currentOption.requiresArg()) {\n            if (isJavaProperty(currentOption.getKey()) && currentOption.getValuesList().size() == 1) {\n                return;\n            }\n            throw new MissingArgumentException(currentOption);\n        }\n    }",
        "start": 229,
        "end": 236,
        "location": [],
        "fixed_class_path": "src/main/java/org/apache/commons/cli/DefaultParser.java"
    },
    "Codec-159": {
        "buggy": "    @Override\n    void decode(final byte[] data, int offset, final int length, final Context context) {\n        if (context.eof || length < 0) {\n            context.eof = true;\n            if (context.ibitWorkArea != 0) {\n                validateTrailingCharacter();\n            }\n            return;\n        }\n\n        final int dataLen = Math.min(data.length - offset, length);\n        final int availableChars = (context.ibitWorkArea != 0 ? 1 : 0) + dataLen;\n\n        // small optimisation to short-cut the rest of this method when it is fed byte-by-byte\n        if (availableChars == 1 && availableChars == dataLen) {\n            // store 1/2 byte for next invocation of decode, we offset by +1 as empty-value is 0\n            context.ibitWorkArea = decodeOctet(data[offset]) + 1;\n            return;\n        }\n\n        // we must have an even number of chars to decode\n        final int charsToProcess = availableChars % BYTES_PER_ENCODED_BLOCK == 0 ? availableChars : availableChars - 1;\n\n        final byte[] buffer = ensureBufferSize(charsToProcess / BYTES_PER_ENCODED_BLOCK, context);\n\n        int result;\n        int i = 0;\n        if (dataLen < availableChars) {\n            // we have 1/2 byte from previous invocation to decode\n            result = (context.ibitWorkArea - 1) << BITS_PER_ENCODED_BYTE;\n            result |= decodeOctet(data[offset++]);\n            i = 2;\n\n            buffer[context.pos++] = (byte)result;\n\n            // reset to empty-value for next invocation!\n            context.ibitWorkArea = 0;\n        }\n\n        while (i < charsToProcess) {\n            result = decodeOctet(data[offset++]) << BITS_PER_ENCODED_BYTE;\n            result |= decodeOctet(data[offset++]);\n            i += 2;\n            buffer[context.pos++] = (byte)result;\n        }\n\n        // we have one char of a hex-pair left over\n        if (i < dataLen) {\n            // store 1/2 byte for next invocation of decode, we offset by +1 as empty-value is 0\n            context.ibitWorkArea = decodeOctet(data[i]) + 1;\n        }\n    }",
        "fix": "    @Override\n    void decode(final byte[] data, int offset, final int length, final Context context) {\n        if (context.eof || length < 0) {\n            context.eof = true;\n            if (context.ibitWorkArea != 0) {\n                validateTrailingCharacter();\n            }\n            return;\n        }\n\n        final int dataLen = Math.min(data.length - offset, length);\n        final int availableChars = (context.ibitWorkArea != 0 ? 1 : 0) + dataLen;\n\n        // small optimisation to short-cut the rest of this method when it is fed byte-by-byte\n        if (availableChars == 1 && availableChars == dataLen) {\n            // store 1/2 byte for next invocation of decode, we offset by +1 as empty-value is 0\n            context.ibitWorkArea = decodeOctet(data[offset]) + 1;\n            return;\n        }\n\n        // we must have an even number of chars to decode\n        final int charsToProcess = availableChars % BYTES_PER_ENCODED_BLOCK == 0 ? availableChars : availableChars - 1;\n        final int end = offset + dataLen;\n\n        final byte[] buffer = ensureBufferSize(charsToProcess / BYTES_PER_ENCODED_BLOCK, context);\n\n        int result;\n        if (dataLen < availableChars) {\n            // we have 1/2 byte from previous invocation to decode\n            result = (context.ibitWorkArea - 1) << BITS_PER_ENCODED_BYTE;\n            result |= decodeOctet(data[offset++]);\n\n            buffer[context.pos++] = (byte)result;\n\n            // reset to empty-value for next invocation!\n            context.ibitWorkArea = 0;\n        }\n\n        final int loopEnd = end - 1;\n        while (offset < loopEnd) {\n            result = decodeOctet(data[offset++]) << BITS_PER_ENCODED_BYTE;\n            result |= decodeOctet(data[offset++]);\n            buffer[context.pos++] = (byte)result;\n        }\n\n        // we have one char of a hex-pair left over\n        if (offset < end) {\n            // store 1/2 byte for next invocation of decode, we offset by +1 as empty-value is 0\n            context.ibitWorkArea = decodeOctet(data[offset]) + 1;\n        }\n    }",
        "start": 149,
        "end": 200,
        "location": [
            175,
            180,
            188,
            191,
            196,
            198
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/codec/binary/Base16.java"
    },
    "Codec-161": {
        "buggy": "    public String encode(String input, final Languages.LanguageSet languageSet) {\n        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);\n        // rules common across many (all) languages\n        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, \"common\");\n        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages\n        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);\n\n        // tidy the input\n        // lower case is a locale-dependent operation\n        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();\n\n        if (this.nameType == NameType.GENERIC) {\n            if (input.startsWith(\"d'\")) { // check for d'\n                final String remainder = input.substring(2);\n                final String combined = \"d\" + remainder;\n                return \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\";\n            }\n            for (final String l : NAME_PREFIXES.get(this.nameType)) {\n                // handle generic prefixes\n                if (input.startsWith(l + \" \")) {\n                    // check for any prefix in the words list\n                    final String remainder = input.substring(l.length() + 1); // input without the prefix\n                    final String combined = l + remainder; // input with prefix without space\n                    return \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\";\n                }\n            }\n        }\n\n        final List<String> words = Arrays.asList(input.split(\"\\\\s+\"));\n        final List<String> words2 = new ArrayList<>();\n\n        // special-case handling of word prefixes based upon the name type\n        switch (this.nameType) {\n        case SEPHARDIC:\n            words.forEach(aWord -> {\n                final String[] parts = aWord.split(\"'\");\n                words2.add(parts[parts.length - 1]);\n            });\n            words2.removeAll(NAME_PREFIXES.get(this.nameType));\n            break;\n        case ASHKENAZI:\n            words2.addAll(words);\n            words2.removeAll(NAME_PREFIXES.get(this.nameType));\n            break;\n        case GENERIC:\n            words2.addAll(words);\n            break;\n        default:\n            throw new IllegalStateException(\"Unreachable case: \" + this.nameType);\n        }\n\n        if (this.concat) {\n            // concat mode enabled\n            input = join(words2, \" \");\n        } else if (words2.size() == 1) {\n            // not a multi-word name\n            input = words.iterator().next();\n        } else {\n            // encode each word in a multi-word name separately (normally used for approx matches)\n            final StringBuilder result = new StringBuilder();\n            words2.forEach(word -> result.append(\"-\").append(encode(word)));\n            // return the result without the leading \"-\"\n            return result.substring(1);\n        }\n\n        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);\n\n        // loop over each char in the input - we will handle the increment manually\n        for (int i = 0; i < input.length();) {\n            final RulesApplication rulesApplication =\n                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();\n            i = rulesApplication.getI();\n            phonemeBuilder = rulesApplication.getPhonemeBuilder();\n        }\n\n        // Apply the general rules\n        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);\n        // Apply the language-specific rules\n        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);\n\n        return phonemeBuilder.makeString();\n    }",
        "fix": "    public String encode(String input, final Languages.LanguageSet languageSet) {\n        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);\n        // rules common across many (all) languages\n        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, \"common\");\n        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages\n        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);\n\n        // tidy the input\n        // lower case is a locale-dependent operation\n        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();\n\n        if (this.nameType == NameType.GENERIC) {\n            if (input.startsWith(\"d'\")) { // check for d'\n                final String remainder = input.substring(2);\n                final String combined = \"d\" + remainder;\n                return \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\";\n            }\n            for (final String l : NAME_PREFIXES.get(this.nameType)) {\n                // handle generic prefixes\n                if (input.startsWith(l + \" \")) {\n                    // check for any prefix in the words list\n                    final String remainder = input.substring(l.length() + 1); // input without the prefix\n                    final String combined = l + remainder; // input with prefix without space\n                    return \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\";\n                }\n            }\n        }\n\n        final List<String> words = Arrays.asList(input.split(\"\\\\s+\"));\n        final List<String> words2 = new ArrayList<>();\n\n        // special-case handling of word prefixes based upon the name type\n        switch (this.nameType) {\n        case SEPHARDIC:\n            words.forEach(aWord -> {\n                final String[] parts = aWord.split(\"'\", -1);\n                words2.add(parts[parts.length - 1]);\n            });\n            words2.removeAll(NAME_PREFIXES.get(this.nameType));\n            break;\n        case ASHKENAZI:\n            words2.addAll(words);\n            words2.removeAll(NAME_PREFIXES.get(this.nameType));\n            break;\n        case GENERIC:\n            words2.addAll(words);\n            break;\n        default:\n            throw new IllegalStateException(\"Unreachable case: \" + this.nameType);\n        }\n\n        if (this.concat) {\n            // concat mode enabled\n            input = join(words2, \" \");\n        } else if (words2.size() == 1) {\n            // not a multi-word name\n            input = words.iterator().next();\n        } else if (!words2.isEmpty()) {\n            // encode each word in a multi-word name separately (normally used for approx matches)\n            final StringBuilder result = new StringBuilder();\n            words2.forEach(word -> result.append(\"-\").append(encode(word)));\n            // return the result without the leading \"-\"\n            return result.substring(1);\n        }\n\n        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);\n\n        // loop over each char in the input - we will handle the increment manually\n        for (int i = 0; i < input.length();) {\n            final RulesApplication rulesApplication =\n                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();\n            i = rulesApplication.getI();\n            phonemeBuilder = rulesApplication.getPhonemeBuilder();\n        }\n\n        // Apply the general rules\n        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);\n        // Apply the language-specific rules\n        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);\n\n        return phonemeBuilder.makeString();\n    }",
        "start": 377,
        "end": 458,
        "location": [
            412,
            434
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java"
    },
    "Codec-163": {
        "buggy": "    public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes, final boolean strict) {\n        if (bytes == null) {\n            return null;\n        }\n        if (printable == null) {\n            printable = PRINTABLE_CHARS;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        final int bytesLength = bytes.length;\n\n        if (strict) {\n            int pos = 1;\n            // encode up to buffer.length - 3, the last three octets will be treated\n            // separately for simplification of note #3\n            for (int i = 0; i < bytesLength - 3; i++) {\n                final int b = getUnsignedOctet(i, bytes);\n                if (pos < SAFE_LENGTH) {\n                    // up to this length it is safe to add any byte, encoded or not\n                    pos += encodeByte(b, !printable.get(b), buffer);\n                } else {\n                    // rule #3: whitespace at the end of a line *must* be encoded\n                    encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);\n\n                    // rule #5: soft line break\n                    buffer.write(ESCAPE_CHAR);\n                    buffer.write(CR);\n                    buffer.write(LF);\n                    pos = 1;\n                }\n            }\n\n            // rule #3: whitespace at the end of a line *must* be encoded\n            // if we would do a soft break line after this octet, encode whitespace\n            int b = getUnsignedOctet(bytesLength - 3, bytes);\n            boolean encode = !printable.get(b) || isWhitespace(b) && pos > SAFE_LENGTH - 5;\n            pos += encodeByte(b, encode, buffer);\n\n            // note #3: '=' *must not* be the ultimate or penultimate character\n            // simplification: if < 6 bytes left, do a soft line break as we may need\n            //                 exactly 6 bytes space for the last 2 bytes\n            if (pos > SAFE_LENGTH - 2) {\n                buffer.write(ESCAPE_CHAR);\n                buffer.write(CR);\n                buffer.write(LF);\n            }\n            for (int i = bytesLength - 2; i < bytesLength; i++) {\n                b = getUnsignedOctet(i, bytes);\n                // rule #3: trailing whitespace shall be encoded\n                encode = !printable.get(b) || i > bytesLength - 2 && isWhitespace(b);\n                encodeByte(b, encode, buffer);\n            }\n        } else {\n            for (final byte c : bytes) {\n                int b = c;\n                if (b < 0) {\n                    b = 256 + b;\n                }\n                if (printable.get(b)) {\n                    buffer.write(b);\n                } else {\n                    encodeQuotedPrintable(b, buffer);\n                }\n            }\n        }\n        return buffer.toByteArray();\n    }",
        "fix": "    public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes, final boolean strict) {\n        if (bytes == null) {\n            return null;\n        }\n        if (printable == null) {\n            printable = PRINTABLE_CHARS;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        final int bytesLength = bytes.length;\n\n        if (strict) {\n            if (bytesLength < MIN_BYTES) {\n                return null;\n            }\n\n            int pos = 1;\n            // encode up to buffer.length - 3, the last three octets will be treated\n            // separately for simplification of note #3\n            for (int i = 0; i < bytesLength - 3; i++) {\n                final int b = getUnsignedOctet(i, bytes);\n                if (pos < SAFE_LENGTH) {\n                    // up to this length it is safe to add any byte, encoded or not\n                    pos += encodeByte(b, !printable.get(b), buffer);\n                } else {\n                    // rule #3: whitespace at the end of a line *must* be encoded\n                    encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);\n\n                    // rule #5: soft line break\n                    buffer.write(ESCAPE_CHAR);\n                    buffer.write(CR);\n                    buffer.write(LF);\n                    pos = 1;\n                }\n            }\n\n            // rule #3: whitespace at the end of a line *must* be encoded\n            // if we would do a soft break line after this octet, encode whitespace\n            int b = getUnsignedOctet(bytesLength - 3, bytes);\n            boolean encode = !printable.get(b) || isWhitespace(b) && pos > SAFE_LENGTH - 5;\n            pos += encodeByte(b, encode, buffer);\n\n            // note #3: '=' *must not* be the ultimate or penultimate character\n            // simplification: if < 6 bytes left, do a soft line break as we may need\n            //                 exactly 6 bytes space for the last 2 bytes\n            if (pos > SAFE_LENGTH - 2) {\n                buffer.write(ESCAPE_CHAR);\n                buffer.write(CR);\n                buffer.write(LF);\n            }\n            for (int i = bytesLength - 2; i < bytesLength; i++) {\n                b = getUnsignedOctet(i, bytes);\n                // rule #3: trailing whitespace shall be encoded\n                encode = !printable.get(b) || i > bytesLength - 2 && isWhitespace(b);\n                encodeByte(b, encode, buffer);\n            }\n        } else {\n            for (final byte c : bytes) {\n                int b = c;\n                if (b < 0) {\n                    b = 256 + b;\n                }\n                if (printable.get(b)) {\n                    buffer.write(b);\n                } else {\n                    encodeQuotedPrintable(b, buffer);\n                }\n            }\n        }\n        return buffer.toByteArray();\n    }",
        "start": 205,
        "end": 274,
        "location": [],
        "fixed_class_path": "src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java"
    },
    "Codec-164": {
        "buggy": "    @Override\n    public final String encode(String name) {\n        // Bulletproof for trivial input - NINO\n        if (name == null || EMPTY.equalsIgnoreCase(name) || SPACE.equalsIgnoreCase(name) || name.length() == 1) {\n            return EMPTY;\n        }\n\n        // Preprocessing\n        name = cleanName(name);\n\n        // BEGIN: Actual encoding part of the algorithm...\n        // 1. Delete all vowels unless the vowel begins the word\n        name = removeVowels(name);\n\n        // 2. Remove second consonant from any double consonant\n        name = removeDoubleConsonants(name);\n\n        // 3. Reduce codex to 6 letters by joining the first 3 and last 3 letters\n        name = getFirst3Last3(name);\n\n        return name;\n    }",
        "fix": "    @Override\n    public final String encode(String name) {\n        // Bulletproof for trivial input - NINO\n        if (name == null || EMPTY.equalsIgnoreCase(name) || SPACE.equalsIgnoreCase(name) || name.length() == 1) {\n            return EMPTY;\n        }\n\n        // Preprocessing\n        name = cleanName(name);\n\n        // Bulletproof if name becomes empty after cleanName(name)\n        if (SPACE.equals(name) || name.isEmpty()) {\n            return EMPTY;\n        }\n\n        // BEGIN: Actual encoding part of the algorithm...\n        // 1. Delete all vowels unless the vowel begins the word\n        name = removeVowels(name);\n\n        // Bulletproof if name becomes empty after removeVowels(name)\n        if (SPACE.equals(name) || name.isEmpty()) {\n            return EMPTY;\n        }\n\n        // 2. Remove second consonant from any double consonant\n        name = removeDoubleConsonants(name);\n\n        // 3. Reduce codex to 6 letters by joining the first 3 and last 3 letters\n        name = getFirst3Last3(name);\n\n        return name;\n    }",
        "start": 119,
        "end": 150,
        "location": [],
        "fixed_class_path": "src/main/java/org/apache/commons/codec/language/MatchRatingApproachEncoder.java"
    },
    "Codec-166": {
        "buggy": "    char getMappingCode(final char c) {\n        if (!Character.isLetter(c)) {\n            return 0;\n        }\n        return this.soundexMapping[Character.toUpperCase(c) - 'A'];\n    }",
        "fix": "    char getMappingCode(final char c) {\n        if (!Character.isLetter(c)) {\n            return 0;\n        }\n        final int index = Character.toUpperCase(c) - 'A';\n        if (index < 0 || index >= this.soundexMapping.length) {\n            return 0;\n        }\n        return this.soundexMapping[index];\n    }",
        "start": 172,
        "end": 181,
        "location": [
            176
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/codec/language/RefinedSoundex.java"
    },
    "Collections-186": {
        "buggy": "    public static <E> List<E> removeAll(final Collection<E> collection, final Collection<?> remove) {\n        final List<E> list = new ArrayList<>();\n        for (final E obj : collection) {\n            if (!remove.contains(obj)) {\n                list.add(obj);\n            }\n        }\n        return list;\n    }",
        "fix": "    public static <E> List<E> removeAll(final Collection<E> collection, final Collection<?> remove) {\n        Objects.requireNonNull(collection, \"collection\");\n        Objects.requireNonNull(remove, \"remove\");\n        final List<E> list = new ArrayList<>();\n        for (final E obj : collection) {\n            if (!remove.contains(obj)) {\n                list.add(obj);\n            }\n        }\n        return list;\n    }",
        "start": 535,
        "end": 545,
        "location": [],
        "fixed_class_path": "src/main/java/org/apache/commons/collections4/ListUtils.java"
    },
    "Compress-436": {
        "buggy": "    @Override\n    InputStream decode(final String archiveName, final InputStream in, final long uncompressedLength,\n            final Coder coder, final byte[] password, final int maxMemoryLimitInKb) throws IOException {\n        if (coder.properties == null) {\n            throw new IOException(\"Missing LZMA properties\");\n        }\n        if (coder.properties.length < 1) {\n            throw new IOException(\"LZMA properties too short\");\n        }\n        final byte propsByte = coder.properties[0];\n        final int dictSize = getDictionarySize(coder);\n        if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n            throw new IOException(\"Dictionary larger than 4GiB maximum size used in \" + archiveName);\n        }\n        final int memoryUsageInKb = LZMAInputStream.getMemoryUsage(dictSize, propsByte);\n        if (memoryUsageInKb > maxMemoryLimitInKb) {\n            throw new MemoryLimitException(memoryUsageInKb, maxMemoryLimitInKb);\n        }\n        return new LZMAInputStream(in, uncompressedLength, propsByte, dictSize);\n    }",
        "fix": "    @Override\n    InputStream decode(final String archiveName, final InputStream in, final long uncompressedLength,\n            final Coder coder, final byte[] password, final int maxMemoryLimitInKb) throws IOException {\n        if (coder.properties == null) {\n            throw new IOException(\"Missing LZMA properties\");\n        }\n        if (coder.properties.length < 1) {\n            throw new IOException(\"LZMA properties too short\");\n        }\n        final byte propsByte = coder.properties[0];\n        final int dictSize = getDictionarySize(coder);\n        if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n            throw new IOException(\"Dictionary larger than 4GiB maximum size used in \" + archiveName);\n        }\n        final int memoryUsageInKb = LZMAInputStream.getMemoryUsage(dictSize, propsByte);\n        if (memoryUsageInKb > maxMemoryLimitInKb) {\n            throw new MemoryLimitException(memoryUsageInKb, maxMemoryLimitInKb);\n        }\n        final LZMAInputStream lzmaIn = new LZMAInputStream(in, uncompressedLength, propsByte, dictSize);\n        lzmaIn.enableRelaxedEndCondition();\n        return lzmaIn;\n    }",
        "start": 35,
        "end": 57,
        "location": [
            53
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/compress/archivers/sevenz/LZMADecoder.java"
    },
    "Compress-437": {
        "buggy": "    @Override\n    InputStream decode(final String archiveName, final InputStream in, final long uncompressedLength,\n            final Coder coder, final byte[] password, final int maxMemoryLimitInKb) throws IOException {\n        if (coder.properties == null) {\n            throw new IOException(\"Missing LZMA properties\");\n        }\n        if (coder.properties.length < 1) {\n            throw new IOException(\"LZMA properties too short\");\n        }\n        final byte propsByte = coder.properties[0];\n        final int dictSize = getDictionarySize(coder);\n        if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n            throw new IOException(\"Dictionary larger than 4GiB maximum size used in \" + archiveName);\n        }\n        final int memoryUsageInKb = LZMAInputStream.getMemoryUsage(dictSize, propsByte);\n        if (memoryUsageInKb > maxMemoryLimitInKb) {\n            throw new MemoryLimitException(memoryUsageInKb, maxMemoryLimitInKb);\n        }\n        return new LZMAInputStream(in, uncompressedLength, propsByte, dictSize);\n    }",
        "fix": "    @Override\n    InputStream decode(final String archiveName, final InputStream in, final long uncompressedLength,\n            final Coder coder, final byte[] password, final int maxMemoryLimitInKb) throws IOException {\n        if (coder.properties == null) {\n            throw new IOException(\"Missing LZMA properties\");\n        }\n        if (coder.properties.length < 1) {\n            throw new IOException(\"LZMA properties too short\");\n        }\n        final byte propsByte = coder.properties[0];\n        final int dictSize = getDictionarySize(coder);\n        if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n            throw new IOException(\"Dictionary larger than 4GiB maximum size used in \" + archiveName);\n        }\n        final int memoryUsageInKb = LZMAInputStream.getMemoryUsage(dictSize, propsByte);\n        if (memoryUsageInKb > maxMemoryLimitInKb) {\n            throw new MemoryLimitException(memoryUsageInKb, maxMemoryLimitInKb);\n        }\n        final LZMAInputStream lzmaIn = new LZMAInputStream(in, uncompressedLength, propsByte, dictSize);\n        lzmaIn.enableRelaxedEndCondition();\n        return lzmaIn;\n    }",
        "start": 35,
        "end": 57,
        "location": [
            53
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/compress/archivers/sevenz/LZMADecoder.java"
    },
    "Compress-439": {
        "buggy": "    private void readFilesInfo(final ByteBuffer header, final Archive archive) throws IOException {\n        final int numFilesInt = (int) readUint64(header);\n        final Map<Integer, SevenZArchiveEntry> fileMap = new HashMap<>();\n        BitSet isEmptyStream = null;\n        BitSet isEmptyFile = null;\n        BitSet isAnti = null;\n        while (true) {\n            final int propertyType = getUnsignedByte(header);\n            if (propertyType == 0) {\n                break;\n            }\n            final long size = readUint64(header);\n            switch (propertyType) {\n                case NID.kEmptyStream: {\n                    isEmptyStream = readBits(header, numFilesInt);\n                    break;\n                }\n                case NID.kEmptyFile: {\n                    isEmptyFile = readBits(header, isEmptyStream.cardinality());\n                    break;\n                }\n                case NID.kAnti: {\n                    isAnti = readBits(header, isEmptyStream.cardinality());\n                    break;\n                }\n                case NID.kName: {\n                    /* final int external = */ getUnsignedByte(header);\n                    final byte[] names = new byte[(int) (size - 1)];\n                    final int namesLength = names.length;\n                    get(header, names);\n                    int nextFile = 0;\n                    int nextName = 0;\n                    for (int i = 0; i < namesLength; i += 2) {\n                        if (names[i] == 0 && names[i + 1] == 0) {\n                            checkEntryIsInitialized(fileMap, nextFile);\n                            fileMap.get(nextFile).setName(new String(names, nextName, i - nextName, UTF_16LE));\n                            nextName = i + 2;\n                            nextFile++;\n                        }\n                    }\n                    if (nextName != namesLength || nextFile != numFilesInt) {\n                        throw new IOException(\"Error parsing file names\");\n                    }\n                    break;\n                }\n                case NID.kCTime: {\n                    final BitSet timesDefined = readAllOrBits(header, numFilesInt);\n                    /* final int external = */ getUnsignedByte(header);\n                    for (int i = 0; i < numFilesInt; i++) {\n                        checkEntryIsInitialized(fileMap, i);\n                        final SevenZArchiveEntry entryAtIndex = fileMap.get(i);\n                        entryAtIndex.setHasCreationDate(timesDefined.get(i));\n                        if (entryAtIndex.getHasCreationDate()) {\n                            entryAtIndex.setCreationDate(getLong(header));\n                        }\n                    }\n                    break;\n                }\n                case NID.kATime: {\n                    final BitSet timesDefined = readAllOrBits(header, numFilesInt);\n                    /* final int external = */ getUnsignedByte(header);\n                    for (int i = 0; i < numFilesInt; i++) {\n                        checkEntryIsInitialized(fileMap, i);\n                        final SevenZArchiveEntry entryAtIndex = fileMap.get(i);\n                        entryAtIndex.setHasAccessDate(timesDefined.get(i));\n                        if (entryAtIndex.getHasAccessDate()) {\n                            entryAtIndex.setAccessDate(getLong(header));\n                        }\n                    }\n                    break;\n                }\n                case NID.kMTime: {\n                    final BitSet timesDefined = readAllOrBits(header, numFilesInt);\n                    /* final int external = */ getUnsignedByte(header);\n                    for (int i = 0; i < numFilesInt; i++) {\n                        checkEntryIsInitialized(fileMap, i);\n                        final SevenZArchiveEntry entryAtIndex = fileMap.get(i);\n                        entryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\n                        if (entryAtIndex.getHasLastModifiedDate()) {\n                            entryAtIndex.setLastModifiedDate(getLong(header));\n                        }\n                    }\n                    break;\n                }\n                case NID.kWinAttributes: {\n                    final BitSet attributesDefined = readAllOrBits(header, numFilesInt);\n                    /* final int external = */ getUnsignedByte(header);\n                    for (int i = 0; i < numFilesInt; i++) {\n                        checkEntryIsInitialized(fileMap, i);\n                        final SevenZArchiveEntry entryAtIndex = fileMap.get(i);\n                        entryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\n                        if (entryAtIndex.getHasWindowsAttributes()) {\n                            entryAtIndex.setWindowsAttributes(getInt(header));\n                        }\n                    }\n                    break;\n                }\n                case NID.kDummy: {\n                    // 7z 9.20 asserts the content is all zeros and ignores the property\n                    // Compress up to 1.8.1 would throw an exception, now we ignore it (see COMPRESS-287\n\n                    skipBytesFully(header, size);\n                    break;\n                }\n\n                default: {\n                    // Compress up to 1.8.1 would throw an exception, now we ignore it (see COMPRESS-287\n                    skipBytesFully(header, size);\n                    break;\n                }\n            }\n        }\n        int nonEmptyFileCounter = 0;\n        int emptyFileCounter = 0;\n        for (int i = 0; i < numFilesInt; i++) {\n            final SevenZArchiveEntry entryAtIndex = fileMap.get(i);\n            if (entryAtIndex == null) {\n                continue;\n            }\n            entryAtIndex.setHasStream(isEmptyStream == null || !isEmptyStream.get(i));\n            if (entryAtIndex.hasStream()) {\n                if (archive.subStreamsInfo == null) {\n                    throw new IOException(\"Archive contains file with streams but no subStreamsInfo\");\n                }\n                entryAtIndex.setDirectory(false);\n                entryAtIndex.setAntiItem(false);\n                entryAtIndex.setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\n                entryAtIndex.setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\n                entryAtIndex.setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n                if (entryAtIndex.getSize() < 0) {\n                    throw new IOException(\"broken archive, entry with negative size\");\n                }\n                ++nonEmptyFileCounter;\n            } else {\n                entryAtIndex.setDirectory(isEmptyFile == null || !isEmptyFile.get(emptyFileCounter));\n                entryAtIndex.setAntiItem(isAnti != null && isAnti.get(emptyFileCounter));\n                entryAtIndex.setHasCrc(false);\n                entryAtIndex.setSize(0);\n                ++emptyFileCounter;\n            }\n        }\n        final List<SevenZArchiveEntry> entries = new ArrayList<>();\n        for (final SevenZArchiveEntry e : fileMap.values()) {\n            if (e != null) {\n                entries.add(e);\n            }\n        }\n        archive.files = entries.toArray(SevenZArchiveEntry.EMPTY_SEVEN_Z_ARCHIVE_ENTRY_ARRAY);\n        calculateStreamMap(archive);\n    }",
        "fix": "    private void readFilesInfo(final ByteBuffer header, final Archive archive) throws IOException {\n        final int numFilesInt = (int) readUint64(header);\n        final Map<Integer, SevenZArchiveEntry> fileMap = new LinkedHashMap<>();\n        BitSet isEmptyStream = null;\n        BitSet isEmptyFile = null;\n        BitSet isAnti = null;\n        while (true) {\n            final int propertyType = getUnsignedByte(header);\n            if (propertyType == 0) {\n                break;\n            }\n            final long size = readUint64(header);\n            switch (propertyType) {\n                case NID.kEmptyStream: {\n                    isEmptyStream = readBits(header, numFilesInt);\n                    break;\n                }\n                case NID.kEmptyFile: {\n                    isEmptyFile = readBits(header, isEmptyStream.cardinality());\n                    break;\n                }\n                case NID.kAnti: {\n                    isAnti = readBits(header, isEmptyStream.cardinality());\n                    break;\n                }\n                case NID.kName: {\n                    /* final int external = */ getUnsignedByte(header);\n                    final byte[] names = new byte[(int) (size - 1)];\n                    final int namesLength = names.length;\n                    get(header, names);\n                    int nextFile = 0;\n                    int nextName = 0;\n                    for (int i = 0; i < namesLength; i += 2) {\n                        if (names[i] == 0 && names[i + 1] == 0) {\n                            checkEntryIsInitialized(fileMap, nextFile);\n                            fileMap.get(nextFile).setName(new String(names, nextName, i - nextName, UTF_16LE));\n                            nextName = i + 2;\n                            nextFile++;\n                        }\n                    }\n                    if (nextName != namesLength || nextFile != numFilesInt) {\n                        throw new IOException(\"Error parsing file names\");\n                    }\n                    break;\n                }\n                case NID.kCTime: {\n                    final BitSet timesDefined = readAllOrBits(header, numFilesInt);\n                    /* final int external = */ getUnsignedByte(header);\n                    for (int i = 0; i < numFilesInt; i++) {\n                        checkEntryIsInitialized(fileMap, i);\n                        final SevenZArchiveEntry entryAtIndex = fileMap.get(i);\n                        entryAtIndex.setHasCreationDate(timesDefined.get(i));\n                        if (entryAtIndex.getHasCreationDate()) {\n                            entryAtIndex.setCreationDate(getLong(header));\n                        }\n                    }\n                    break;\n                }\n                case NID.kATime: {\n                    final BitSet timesDefined = readAllOrBits(header, numFilesInt);\n                    /* final int external = */ getUnsignedByte(header);\n                    for (int i = 0; i < numFilesInt; i++) {\n                        checkEntryIsInitialized(fileMap, i);\n                        final SevenZArchiveEntry entryAtIndex = fileMap.get(i);\n                        entryAtIndex.setHasAccessDate(timesDefined.get(i));\n                        if (entryAtIndex.getHasAccessDate()) {\n                            entryAtIndex.setAccessDate(getLong(header));\n                        }\n                    }\n                    break;\n                }\n                case NID.kMTime: {\n                    final BitSet timesDefined = readAllOrBits(header, numFilesInt);\n                    /* final int external = */ getUnsignedByte(header);\n                    for (int i = 0; i < numFilesInt; i++) {\n                        checkEntryIsInitialized(fileMap, i);\n                        final SevenZArchiveEntry entryAtIndex = fileMap.get(i);\n                        entryAtIndex.setHasLastModifiedDate(timesDefined.get(i));\n                        if (entryAtIndex.getHasLastModifiedDate()) {\n                            entryAtIndex.setLastModifiedDate(getLong(header));\n                        }\n                    }\n                    break;\n                }\n                case NID.kWinAttributes: {\n                    final BitSet attributesDefined = readAllOrBits(header, numFilesInt);\n                    /* final int external = */ getUnsignedByte(header);\n                    for (int i = 0; i < numFilesInt; i++) {\n                        checkEntryIsInitialized(fileMap, i);\n                        final SevenZArchiveEntry entryAtIndex = fileMap.get(i);\n                        entryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));\n                        if (entryAtIndex.getHasWindowsAttributes()) {\n                            entryAtIndex.setWindowsAttributes(getInt(header));\n                        }\n                    }\n                    break;\n                }\n                case NID.kDummy: {\n                    // 7z 9.20 asserts the content is all zeros and ignores the property\n                    // Compress up to 1.8.1 would throw an exception, now we ignore it (see COMPRESS-287\n\n                    skipBytesFully(header, size);\n                    break;\n                }\n\n                default: {\n                    // Compress up to 1.8.1 would throw an exception, now we ignore it (see COMPRESS-287\n                    skipBytesFully(header, size);\n                    break;\n                }\n            }\n        }\n        int nonEmptyFileCounter = 0;\n        int emptyFileCounter = 0;\n        for (int i = 0; i < numFilesInt; i++) {\n            final SevenZArchiveEntry entryAtIndex = fileMap.get(i);\n            if (entryAtIndex == null) {\n                continue;\n            }\n            entryAtIndex.setHasStream(isEmptyStream == null || !isEmptyStream.get(i));\n            if (entryAtIndex.hasStream()) {\n                if (archive.subStreamsInfo == null) {\n                    throw new IOException(\"Archive contains file with streams but no subStreamsInfo\");\n                }\n                entryAtIndex.setDirectory(false);\n                entryAtIndex.setAntiItem(false);\n                entryAtIndex.setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\n                entryAtIndex.setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\n                entryAtIndex.setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n                if (entryAtIndex.getSize() < 0) {\n                    throw new IOException(\"broken archive, entry with negative size\");\n                }\n                ++nonEmptyFileCounter;\n            } else {\n                entryAtIndex.setDirectory(isEmptyFile == null || !isEmptyFile.get(emptyFileCounter));\n                entryAtIndex.setAntiItem(isAnti != null && isAnti.get(emptyFileCounter));\n                entryAtIndex.setHasCrc(false);\n                entryAtIndex.setSize(0);\n                ++emptyFileCounter;\n            }\n        }\n        final List<SevenZArchiveEntry> entries = new ArrayList<>();\n        for (final SevenZArchiveEntry e : fileMap.values()) {\n            if (e != null) {\n                entries.add(e);\n            }\n        }\n        archive.files = entries.toArray(SevenZArchiveEntry.EMPTY_SEVEN_Z_ARCHIVE_ENTRY_ARRAY);\n        calculateStreamMap(archive);\n    }",
        "start": 1368,
        "end": 1518,
        "location": [
            1370
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java"
    },
    "Compress-452": {
        "buggy": "    private UnionCase readNextUnionCase(final StringReader stream) throws IOException {\n        stream.mark(2);\n        stream.read(); // '('\n        char next = (char) stream.read();\n        if (next == ')'|| next == -1) {\n            stream.reset();\n            return null;\n        }\n        stream.reset();\n        stream.read(); // '('\n        final List<Integer> tags = new ArrayList<>();\n        Integer nextTag;\n        do {\n            nextTag = readNumber(stream);\n            if (nextTag != null) {\n                tags.add(nextTag);\n                stream.read(); // ',' or ')'\n            }\n        } while (nextTag != null);\n        stream.read(); // '['\n        stream.mark(1);\n        next = (char) stream.read();\n        if (next == ']') {\n            return new UnionCase(tags);\n        }\n        stream.reset();\n        return new UnionCase(tags, readBody(getStreamUpToMatchingBracket(stream)));\n    }",
        "fix": "    private UnionCase readNextUnionCase(final StringReader stream) throws IOException {\n        stream.mark(2);\n        stream.read(); // '('\n        final int next = stream.read();\n        char ch = (char) next;\n        if (ch == ')'|| next == -1) {\n            stream.reset();\n            return null;\n        }\n        stream.reset();\n        stream.read(); // '('\n        final List<Integer> tags = new ArrayList<>();\n        Integer nextTag;\n        do {\n            nextTag = readNumber(stream);\n            if (nextTag != null) {\n                tags.add(nextTag);\n                stream.read(); // ',' or ')'\n            }\n        } while (nextTag != null);\n        stream.read(); // '['\n        stream.mark(1);\n        ch = (char) stream.read();\n        if (ch == ']') {\n            return new UnionCase(tags);\n        }\n        stream.reset();\n        return new UnionCase(tags, readBody(getStreamUpToMatchingBracket(stream)));\n    }",
        "start": 288,
        "end": 316,
        "location": [
            291,
            292,
            309,
            310
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/compress/harmony/unpack200/NewAttributeBands.java"
    },
    "Compress-461": {
        "buggy": "    private void pushback(final byte[] buf, final int offset, final int length) throws IOException {\n        ((PushbackInputStream) inputStream).unread(buf, offset, length);\n        pushedBackBytes(length);\n    }",
        "fix": "    private void pushback(final byte[] buf, final int offset, final int length) throws IOException {\n        if (offset < 0) {\n            // Instead of ArrayIndexOutOfBoundsException\n            throw new IOException(String.format(\"Negative offset %,d into buffer\", offset));\n        }\n        ((PushbackInputStream) inputStream).unread(buf, offset, length);\n        pushedBackBytes(length);\n    }",
        "start": 985,
        "end": 993,
        "location": [],
        "fixed_class_path": "src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java"
    },
    "Compress-465": {
        "buggy": "    public boolean isFile() {\n        if (file != null) {\n            return Files.isRegularFile(file, linkOptions);\n        }\n        if (linkFlag == LF_OLDNORM || linkFlag == LF_NORMAL) {\n            return true;\n        }\n        return !getName().endsWith(\"/\");\n    }",
        "fix": "    public boolean isFile() {\n        if (file != null) {\n            return Files.isRegularFile(file, linkOptions);\n        }\n        if (linkFlag == LF_OLDNORM || linkFlag == LF_NORMAL) {\n            return true;\n        }\n        return linkFlag != LF_DIR && !getName().endsWith(\"/\");\n    }",
        "start": 1237,
        "end": 1245,
        "location": [
            1244
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java"
    },
    "Compress-469": {
        "buggy": "    public static boolean isDosTime(final long time) {\n        return time <= UPPER_DOSTIME_BOUND && javaToDosTime(time) != DOSTIME_BEFORE_1980;\n    }",
        "fix": "    public static boolean isDosTime(final long time) {\n        return time <= UPPER_DOSTIME_BOUND &&\n                (time == DOSTIME_BEFORE_1980_AS_JAVA_TIME || javaToDosTime(time) != DOSTIME_BEFORE_1980);\n    }",
        "start": 235,
        "end": 238,
        "location": [
            236
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/compress/archivers/zip/ZipUtil.java"
    },
    "Compress-476": {
        "buggy": "    private boolean readFirstLocalFileHeader() throws IOException {\n        try {\n            // for empty archive, we may get only EOCD size:\n            final byte[] header = new byte[Math.min(LFH_LEN, ZipFile.MIN_EOCD_SIZE)];\n            readFully(header);\n            READ_LOOP: for (int i = 0; ; ) {\n                for (int j = 0; i <= PREAMBLE_GARBAGE_MAX_SIZE - 4 && j <= header.length - 4; ++j, ++i) {\n                    final ZipLong sig = new ZipLong(header, j);\n                    if (\n                            sig.equals(ZipLong.LFH_SIG) ||\n                            sig.equals(ZipLong.SINGLE_SEGMENT_SPLIT_MARKER) ||\n                            sig.equals(ZipLong.DD_SIG)) {\n                        // regular archive containing at least one entry:\n                        System.arraycopy(header, j, header, 0, header.length - j);\n                        readFully(header, header.length - j);\n                        break READ_LOOP;\n                    }\n                    if (\n                            sig.equals(new ZipLong(ZipArchiveOutputStream.EOCD_SIG))\n                    ) {\n                        // empty archive:\n                        pushback(header, j, header.length - j);\n                        return false;\n                    }\n                }\n                if (i >= PREAMBLE_GARBAGE_MAX_SIZE - 4) {\n                    throw new ZipException(\"Cannot find zip signature within the first \" + PREAMBLE_GARBAGE_MAX_SIZE + \" bytes\");\n                }\n                System.arraycopy(header, header.length - 3, header, 0, 3);\n                readFully(header, 3);\n            }\n            System.arraycopy(header, 0, lfhBuf, 0, header.length);\n            readFully(lfhBuf, header.length);\n        } catch (final EOFException ex) {\n            throw new ZipException(\"Cannot find zip signature within the file\");\n        }\n        final ZipLong sig = new ZipLong(lfhBuf);\n\n        if (!skipSplitSig && sig.equals(ZipLong.DD_SIG)) {\n            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.SPLITTING);\n        }\n\n        // the split ZIP signature(08074B50) should only be skipped when the skipSplitSig is set\n        if (sig.equals(ZipLong.SINGLE_SEGMENT_SPLIT_MARKER) || sig.equals(ZipLong.DD_SIG)) {\n            // Just skip over the marker.\n            System.arraycopy(lfhBuf, 4, lfhBuf, 0, lfhBuf.length - 4);\n            readFully(lfhBuf, lfhBuf.length - 4);\n        }\n        return true;\n    }",
        "fix": "    private boolean readFirstLocalFileHeader() throws IOException {\n        // for empty archive, we may get only EOCD size:\n        final byte[] header = new byte[Math.min(LFH_LEN, ZipFile.MIN_EOCD_SIZE)];\n        readFully(header);\n        try {\n            READ_LOOP: for (int i = 0; ; ) {\n                for (int j = 0; i <= PREAMBLE_GARBAGE_MAX_SIZE - 4 && j <= header.length - 4; ++j, ++i) {\n                    final ZipLong sig = new ZipLong(header, j);\n                    if (\n                            sig.equals(ZipLong.LFH_SIG) ||\n                            sig.equals(ZipLong.SINGLE_SEGMENT_SPLIT_MARKER) ||\n                            sig.equals(ZipLong.DD_SIG)) {\n                        // regular archive containing at least one entry:\n                        System.arraycopy(header, j, header, 0, header.length - j);\n                        readFully(header, header.length - j);\n                        break READ_LOOP;\n                    }\n                    if (\n                            sig.equals(new ZipLong(ZipArchiveOutputStream.EOCD_SIG))\n                    ) {\n                        // empty archive:\n                        pushback(header, j, header.length - j);\n                        return false;\n                    }\n                }\n                if (i >= PREAMBLE_GARBAGE_MAX_SIZE - 4) {\n                    throw new ZipException(\"Cannot find zip signature within the first \" + PREAMBLE_GARBAGE_MAX_SIZE + \" bytes\");\n                }\n                System.arraycopy(header, header.length - 3, header, 0, 3);\n                readFully(header, 3);\n            }\n            System.arraycopy(header, 0, lfhBuf, 0, header.length);\n            readFully(lfhBuf, header.length);\n        } catch (final EOFException ex) {\n            throw new ZipException(\"Cannot find zip signature within the file\");\n        }\n        final ZipLong sig = new ZipLong(lfhBuf);\n\n        if (!skipSplitSig && sig.equals(ZipLong.DD_SIG)) {\n            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.SPLITTING);\n        }\n\n        // the split ZIP signature(08074B50) should only be skipped when the skipSplitSig is set\n        if (sig.equals(ZipLong.SINGLE_SEGMENT_SPLIT_MARKER) || sig.equals(ZipLong.DD_SIG)) {\n            // Just skip over the marker.\n            System.arraycopy(lfhBuf, 4, lfhBuf, 0, lfhBuf.length - 4);\n            readFully(lfhBuf, lfhBuf.length - 4);\n        }\n        return true;\n    }",
        "start": 1014,
        "end": 1063,
        "location": [
            1016,
            1017,
            1018
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java"
    },
    "Csv-117": {
        "buggy": "    public String get(final Enum<?> e) {\n        return get(Objects.toString(e, null));\n    }",
        "fix": "    public String get(final Enum<?> e) {\n        return get(e == null ? null : e.name());\n    }",
        "start": 74,
        "end": 76,
        "location": [
            75
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/csv/CSVRecord.java"
    },
    "Csv-124": {
        "buggy": "    private Headers createHeaders() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        List<String> headerNames = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = createEmptyHeaderMap();\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                    headerComment = nextRecord.getComment();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    final CSVRecord nextRecord = this.nextRecord();\n                    if (nextRecord != null) {\n                        headerComment = nextRecord.getComment();\n                    }\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean blankHeader = CSVFormat.isBlank(header);\n                    if (blankHeader && !this.format.getAllowMissingColumnNames()) {\n                        throw new IllegalArgumentException(\n                            \"A header name is missing in \" + Arrays.toString(headerRecord));\n                    }\n\n                    final boolean containsHeader = header != null && hdrMap.containsKey(header);\n                    final DuplicateHeaderMode headerMode = this.format.getDuplicateHeaderMode();\n                    final boolean duplicatesAllowed = headerMode == DuplicateHeaderMode.ALLOW_ALL;\n                    final boolean emptyDuplicatesAllowed = headerMode == DuplicateHeaderMode.ALLOW_EMPTY;\n\n                    if (containsHeader && !duplicatesAllowed && !(blankHeader && emptyDuplicatesAllowed)) {\n                        throw new IllegalArgumentException(\n                            String.format(\n                                \"The header contains a duplicate name: \\\"%s\\\" in %s. If this is valid then use CSVFormat.Builder.setDuplicateHeaderMode().\",\n                                header, Arrays.toString(headerRecord)));\n                    }\n                    if (header != null) {\n                        hdrMap.put(header, Integer.valueOf(i));\n                        if (headerNames == null) {\n                            headerNames = new ArrayList<>(headerRecord.length);\n                        }\n                        headerNames.add(header);\n                    }\n                }\n            }\n        }\n        if (headerNames == null) {\n            headerNames = Collections.emptyList(); // immutable\n        } else {\n            headerNames = Collections.unmodifiableList(headerNames);\n        }\n        return new Headers(hdrMap, headerNames);\n    }",
        "fix": "    private Headers createHeaders() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        List<String> headerNames = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = createEmptyHeaderMap();\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                    headerComment = nextRecord.getComment();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    final CSVRecord nextRecord = this.nextRecord();\n                    if (nextRecord != null) {\n                        headerComment = nextRecord.getComment();\n                    }\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                // Track an occurrence of a null, empty or blank header.\n                boolean observedMissing = false;\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean blankHeader = CSVFormat.isBlank(header);\n                    if (blankHeader && !this.format.getAllowMissingColumnNames()) {\n                        throw new IllegalArgumentException(\n                            \"A header name is missing in \" + Arrays.toString(headerRecord));\n                    }\n\n                    final boolean containsHeader = blankHeader ? observedMissing : hdrMap.containsKey(header);\n                    final DuplicateHeaderMode headerMode = this.format.getDuplicateHeaderMode();\n                    final boolean duplicatesAllowed = headerMode == DuplicateHeaderMode.ALLOW_ALL;\n                    final boolean emptyDuplicatesAllowed = headerMode == DuplicateHeaderMode.ALLOW_EMPTY;\n\n                    if (containsHeader && !duplicatesAllowed && !(blankHeader && emptyDuplicatesAllowed)) {\n                        throw new IllegalArgumentException(\n                            String.format(\n                                \"The header contains a duplicate name: \\\"%s\\\" in %s. If this is valid then use CSVFormat.Builder.setDuplicateHeaderMode().\",\n                                header, Arrays.toString(headerRecord)));\n                    }\n                    observedMissing |= blankHeader;\n                    if (header != null) {\n                        hdrMap.put(header, Integer.valueOf(i));\n                        if (headerNames == null) {\n                            headerNames = new ArrayList<>(headerRecord.length);\n                        }\n                        headerNames.add(header);\n                    }\n                }\n            }\n        }\n        if (headerNames == null) {\n            headerNames = Collections.emptyList(); // immutable\n        } else {\n            headerNames = Collections.unmodifiableList(headerNames);\n        }\n        return new Headers(hdrMap, headerNames);\n    }",
        "start": 476,
        "end": 540,
        "location": [
            510
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/csv/CSVParser.java"
    },
    "Jsoup-85": {
        "buggy": "    public static boolean isBooleanAttribute(final String key) {\n        return Arrays.binarySearch(booleanAttributes, key) >= 0;\n    }",
        "fix": "    public static boolean isBooleanAttribute(final String key) {\n        return Arrays.binarySearch(booleanAttributes, Normalizer.lowerCase(key)) >= 0;\n    }",
        "start": 214,
        "end": 216,
        "location": [
            215
        ],
        "fixed_class_path": "src/main/java/org/jsoup/nodes/Attribute.java"
    },
    "Jsoup-88": {
        "buggy": "    public ByteBuffer readToByteBuffer(int max) throws IOException {\n        Validate.isTrue(max >= 0, \"maxSize must be 0 (unlimited) or larger\");\n        final boolean localCapped = max > 0; // still possibly capped in total stream\n        final int bufferSize = localCapped && max < DefaultSize ? max : DefaultSize;\n        final byte[] readBuffer = new byte[bufferSize];\n        final ByteArrayOutputStream outStream = new ByteArrayOutputStream(bufferSize);\n\n        int read;\n        int remaining = bufferSize;\n\n        while (true) {\n            read = read(readBuffer, 0, remaining);\n            if (read == -1) break;\n            if (localCapped) { // this local byteBuffer cap may be smaller than the overall maxSize (like when reading first bytes)\n                if (read >= remaining) {\n                    outStream.write(readBuffer, 0, remaining);\n                    break;\n                }\n                remaining -= read;\n            }\n            outStream.write(readBuffer, 0, read);\n        }\n        return ByteBuffer.wrap(outStream.toByteArray());\n    }",
        "fix": "    public ByteBuffer readToByteBuffer(int max) throws IOException {\n        Validate.isTrue(max >= 0, \"maxSize must be 0 (unlimited) or larger\");\n        final boolean localCapped = max > 0; // still possibly capped in total stream\n        final int bufferSize = localCapped && max < DefaultSize ? max : DefaultSize;\n        final byte[] readBuffer = new byte[bufferSize];\n        final ByteArrayOutputStream outStream = new ByteArrayOutputStream(bufferSize);\n\n        int read;\n        while (true) {\n            read = read(readBuffer, 0, bufferSize);\n            if (read == -1) break;\n            if (localCapped) { // this local byteBuffer cap may be smaller than the overall maxSize (like when reading first bytes)\n                if (read >= max) {\n                    outStream.write(readBuffer, 0, max);\n                    break;\n                }\n            }\n            outStream.write(readBuffer, 0, read);\n        }\n        return ByteBuffer.wrap(outStream.toByteArray());\n    }",
        "start": 76,
        "end": 96,
        "location": [
            84,
            87,
            90,
            91,
            94
        ],
        "fixed_class_path": "src/main/java/org/jsoup/internal/ConstrainableInputStream.java"
    },
    "Jsoup-89": {
        "buggy": "    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;\n        final boolean parentIndent = parent != null && parent.shouldIndent(out);\n        final boolean blank = isBlank();\n\n        if (parentIndent && StringUtil.startsWithNewline(coreValue()) && blank) // we are skippable whitespace\n            return;\n\n        if (prettyPrint && ((siblingIndex == 0 && parent != null && parent.tag().formatAsBlock() && !blank) || (out.outline() && siblingNodes().size()>0 && !blank) ))\n            indent(accum, depth, out);\n\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode);\n        final boolean stripWhite = prettyPrint && parentNode instanceof Document;\n        Entities.escape(accum, coreValue(), out, false, normaliseWhite, stripWhite);\n    }",
        "fix": "    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;\n        final boolean parentIndent = parent != null && parent.shouldIndent(out);\n        final boolean blank = isBlank();\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode);\n\n        if (normaliseWhite && parentIndent && StringUtil.startsWithNewline(coreValue()) && blank) // we are skippable whitespace\n            return;\n\n        if (prettyPrint && ((siblingIndex == 0 && parent != null && parent.tag().formatAsBlock() && !blank) || (out.outline() && siblingNodes().size()>0 && !blank) ))\n            indent(accum, depth, out);\n\n        final boolean stripWhite = prettyPrint && parentNode instanceof Document;\n        Entities.escape(accum, coreValue(), out, false, normaliseWhite, stripWhite);\n    }",
        "start": 82,
        "end": 98,
        "location": [
            88,
            94
        ],
        "fixed_class_path": "src/main/java/org/jsoup/nodes/TextNode.java"
    },
    "Jsoup-91": {
        "buggy": "    public ByteBuffer readToByteBuffer(int max) throws IOException {\n        Validate.isTrue(max >= 0, \"maxSize must be 0 (unlimited) or larger\");\n        final boolean localCapped = max > 0; // still possibly capped in total stream\n        final int bufferSize = localCapped && max < DefaultSize ? max : DefaultSize;\n        final byte[] readBuffer = new byte[bufferSize];\n        final ByteArrayOutputStream outStream = new ByteArrayOutputStream(bufferSize);\n\n        int read;\n        while (true) {\n            read = read(readBuffer, 0, bufferSize);\n            if (read == -1) break;\n            if (localCapped) { // this local byteBuffer cap may be smaller than the overall maxSize (like when reading first bytes)\n                if (read >= max) {\n                    outStream.write(readBuffer, 0, max);\n                    break;\n                }\n            }\n            outStream.write(readBuffer, 0, read);\n        }\n        return ByteBuffer.wrap(outStream.toByteArray());\n    }",
        "fix": "    public ByteBuffer readToByteBuffer(int max) throws IOException {\n        Validate.isTrue(max >= 0, \"maxSize must be 0 (unlimited) or larger\");\n        final boolean localCapped = max > 0; // still possibly capped in total stream\n        final int bufferSize = localCapped && max < DefaultSize ? max : DefaultSize;\n        final byte[] readBuffer = new byte[bufferSize];\n        final ByteArrayOutputStream outStream = new ByteArrayOutputStream(bufferSize);\n\n        int read;\n        int remaining = max;\n        while (true) {\n            read = read(readBuffer, 0, localCapped ? Math.min(remaining, bufferSize) : bufferSize);\n            if (read == -1) break;\n            if (localCapped) { // this local byteBuffer cap may be smaller than the overall maxSize (like when reading first bytes)\n                if (read >= remaining) {\n                    outStream.write(readBuffer, 0, remaining);\n                    break;\n                }\n                remaining -= read;\n            }\n            outStream.write(readBuffer, 0, read);\n        }\n        return ByteBuffer.wrap(outStream.toByteArray());\n    }",
        "start": 76,
        "end": 98,
        "location": [
            85,
            88,
            89
        ],
        "fixed_class_path": "src/main/java/org/jsoup/internal/ConstrainableInputStream.java"
    },
    "Jsoup-92": {
        "buggy": "    public String text() {\n        final StringBuilder accum = StringUtil.borrowBuilder();\n        NodeTraversor.traverse(new NodeVisitor() {\n            public void head(Node node, int depth) {\n                if (node instanceof TextNode) {\n                    TextNode textNode = (TextNode) node;\n                    appendNormalisedText(accum, textNode);\n                } else if (node instanceof Element) {\n                    Element element = (Element) node;\n                    if (accum.length() > 0 &&\n                        (element.isBlock() || element.tag.normalName().equals(\"br\")) &&\n                        !TextNode.lastCharIsWhitespace(accum))\n                        accum.append(' ');\n                }\n            }\n\n            public void tail(Node node, int depth) {\n                // make sure there is a space between block tags and immediately following text nodes <div>One</div>Two should be \"One Two\".\n                if (node instanceof Element) {\n                    Element element = (Element) node;\n                    if (element.isBlock() && (node.nextSibling() instanceof TextNode) && !TextNode.lastCharIsWhitespace(accum))\n                        accum.append(' ');\n                }\n\n            }\n        }, this);\n\n        return StringUtil.releaseBuilder(accum).trim();\n    }",
        "fix": "    public String text() {\n        final StringBuilder accum = StringUtil.borrowBuilder();\n        NodeTraversor.traverse(new NodeVisitor() {\n            public void head(Node node, int depth) {\n                if (node instanceof TextNode) {\n                    TextNode textNode = (TextNode) node;\n                    appendNormalisedText(accum, textNode);\n                } else if (node instanceof Element) {\n                    Element element = (Element) node;\n                    if (accum.length() > 0 &&\n                        (element.isBlock() || element.tag.normalName().equals(\"br\")) &&\n                        !TextNode.lastCharIsWhitespace(accum))\n                        accum.append(' ');\n                }\n            }\n\n            public void tail(Node node, int depth) {\n                // make sure there is a space between block tags and immediately following text nodes or inline elements <div>One</div>Two should be \"One Two\".\n                if (node instanceof Element) {\n                    Element element = (Element) node;\n                    Node next = node.nextSibling();\n                    if (element.isBlock() && (next instanceof TextNode || next instanceof Element && !((Element) next).tag.formatAsBlock()) && !TextNode.lastCharIsWhitespace(accum))\n                        accum.append(' ');\n                }\n\n            }\n        }, this);\n\n        return StringUtil.releaseBuilder(accum).trim();\n    }",
        "start": 1305,
        "end": 1334,
        "location": [
            1322,
            1325
        ],
        "fixed_class_path": "src/main/java/org/jsoup/nodes/Element.java"
    },
    "Jsoup-94": {
        "buggy": "    protected void replaceChild(Node out, Node in) {\n        Validate.isTrue(out.parentNode == this);\n        Validate.notNull(in);\n        if (in.parentNode != null)\n            in.parentNode.removeChild(in);\n\n        final int index = out.siblingIndex;\n        ensureChildNodes().set(index, in);\n        in.parentNode = this;\n        in.setSiblingIndex(index);\n        out.parentNode = null;\n    }",
        "fix": "    protected void replaceChild(Node out, Node in) {\n        Validate.isTrue(out.parentNode == this);\n        Validate.notNull(in);\n        if (out == in) return; // no-op self replacement\n\n        if (in.parentNode != null)\n            in.parentNode.removeChild(in);\n\n        final int index = out.siblingIndex;\n        ensureChildNodes().set(index, in);\n        in.parentNode = this;\n        in.setSiblingIndex(index);\n        out.parentNode = null;\n    }",
        "start": 479,
        "end": 493,
        "location": [],
        "fixed_class_path": "src/main/java/org/jsoup/nodes/Node.java"
    },
    "Jsoup-97": {
        "buggy": "    static URL encodeUrl(URL u) {\n\t    u = punyUrl(u);\n        try {\n            // run the URL through URI, so components are encoded\n            URI uri = new URI(u.getProtocol(), u.getUserInfo(), u.getHost(), u.getPort(), u.getPath(), u.getQuery(), u.getRef());\n            return uri.toURL();\n        } catch (URISyntaxException | MalformedURLException e) {\n            // give up and return the original input\n            return u;\n        }\n    }",
        "fix": "    static URL encodeUrl(URL u) {\n\t    u = punyUrl(u);\n        try {\n            // run the URL through URI, so components are encoded\n            URI uri = new URI(\n                u.getProtocol(), decodePart(u.getUserInfo()), u.getHost(), u.getPort(),\n                decodePart(u.getPath()), decodePart(u.getQuery()), decodePart(u.getRef()));\n            return uri.toURL();\n        } catch (URISyntaxException | MalformedURLException | UnsupportedEncodingException e) {\n            // give up and return the original input\n            return u;\n        }\n    }",
        "start": 127,
        "end": 140,
        "location": [
            131,
            133
        ],
        "fixed_class_path": "src/main/java/org/jsoup/helper/HttpConnection.java"
    },
    "Jsoup-98": {
        "buggy": "    public static String escape(String string) {\n        return escape(string, DefaultOutput);\n    }",
        "fix": "    public static String escape(String string) {\n        if (DefaultOutput == null)\n            DefaultOutput = new OutputSettings();\n        return escape(string, DefaultOutput);\n    }",
        "start": 159,
        "end": 163,
        "location": [],
        "fixed_class_path": "src/main/java/org/jsoup/nodes/Entities.java"
    },
    "Jsoup-101": {
        "buggy": "    private boolean isInlineable(Document.OutputSettings out) {\n        if (!tag.isInline())\n            return false;\n        return (parent() == null || parent().isBlock())\n            && !isEffectivelyFirst()\n            && !out.outline();\n    }",
        "fix": "    private boolean isInlineable(Document.OutputSettings out) {\n        if (!tag.isInline())\n            return false;\n        return (parent() == null || parent().isBlock())\n            && !isEffectivelyFirst()\n            && !out.outline()\n            && !isNode(\"br\");\n    }",
        "start": 1848,
        "end": 1856,
        "location": [
            1853
        ],
        "fixed_class_path": "src/main/java/org/jsoup/nodes/Element.java"
    },
    "Jsoup-105": {
        "buggy": "    private boolean isFormatAsBlock(Document.OutputSettings out) {\n        return tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline();\n    }",
        "fix": "    private boolean isFormatAsBlock(Document.OutputSettings out) {\n        return tag.isBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline();\n    }",
        "start": 1845,
        "end": 1848,
        "location": [
            1846
        ],
        "fixed_class_path": "src/main/java/org/jsoup/nodes/Element.java"
    },
    "Jsoup-107": {
        "buggy": "    URL build() {\n        try {\n            // use the URI class to encode non-ascii in path\n            URI uri = new URI(\n                u.getProtocol(),\n                u.getUserInfo(),\n                IDN.toASCII(decodePart(u.getHost())), // puny-code\n                u.getPort(),\n                decodePart(u.getPath()),\n                null, null // query and fragment appended later so as not to encode\n            );\n\n            String normUrl = uri.toASCIIString();\n            if (q != null || u.getRef() != null) {\n                StringBuilder sb = StringUtil.borrowBuilder().append(normUrl);\n                if (q != null) {\n                    sb.append('?');\n                    appendToAscii(StringUtil.releaseBuilder(q), true, sb);\n                }\n                if (u.getRef() != null) {\n                    sb.append('#');\n                    appendToAscii(u.getRef(), false, sb);\n                }\n                normUrl = StringUtil.releaseBuilder(sb);\n            }\n            u =  new URL(normUrl);\n            return u;\n        } catch (MalformedURLException | URISyntaxException | UnsupportedEncodingException e) {\n            // we assert here so that any incomplete normalization issues can be caught in devel. but in practise,\n            // the remote end will be able to handle it, so in prod we just pass the original URL.\n            // The UnsupportedEncodingException would never happen as always UTF8\n            assert Validate.assertFail(e.toString());\n            return u;\n        }\n    }",
        "fix": "    URL build() {\n        try {\n            // use the URI class to encode non-ascii in path\n            URI uri = new URI(\n                u.getProtocol(),\n                u.getUserInfo(),\n                IDN.toASCII(decodePart(u.getHost())), // puny-code\n                u.getPort(),\n                null, null, null // path, query and fragment appended later so as not to encode\n            );\n\n            StringBuilder normUrl = StringUtil.borrowBuilder().append(uri.toASCIIString());\n            appendToAscii(u.getPath(), false, normUrl);\n            if (q != null) {\n                normUrl.append('?');\n                appendToAscii(StringUtil.releaseBuilder(q), true, normUrl);\n            }\n            if (u.getRef() != null) {\n                normUrl.append('#');\n                appendToAscii(u.getRef(), false, normUrl);\n            }\n            u = new URL(StringUtil.releaseBuilder(normUrl));\n            return u;\n        } catch (MalformedURLException | URISyntaxException | UnsupportedEncodingException e) {\n            // we assert here so that any incomplete normalization issues can be caught in devel. but in practise,\n            // the remote end will be able to handle it, so in prod we just pass the original URL.\n            // The UnsupportedEncodingException would never happen as always UTF8\n            assert Validate.assertFail(e.toString());\n            return u;\n        }\n    }",
        "start": 32,
        "end": 63,
        "location": [
            40,
            41,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            57
        ],
        "fixed_class_path": "src/main/java/org/jsoup/helper/UrlBuilder.java"
    },
    "Jsoup-109": {
        "buggy": "    void popStackToClose(String... elNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (inSorted(next.normalName(), elNames))\n                break;\n        }\n    }",
        "fix": "    void popStackToClose(String... elNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            stack.remove(pos);\n            if (inSorted(el.normalName(), elNames)) {\n                if (currentToken instanceof Token.EndTag)\n                    onNodeClosed(el, currentToken);\n                break;\n            }\n        }\n    }",
        "start": 425,
        "end": 435,
        "location": [
            427,
            429
        ],
        "fixed_class_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java"
    },
    "Jsoup-112": {
        "buggy": "    @Override\n    public Element empty() {\n        childNodes.clear();\n        return this;\n    }",
        "fix": "    @Override\n    public Element empty() {\n        // Detach each of the children -> parent links:\n        for (Node child : childNodes) {\n            child.parentNode = null;\n        }\n        childNodes.clear();\n        return this;\n    }",
        "start": 836,
        "end": 844,
        "location": [],
        "fixed_class_path": "src/main/java/org/jsoup/nodes/Element.java"
    },
    "Jsoup-114": {
        "buggy": "    private String consumeSubQuery() {\n        StringBuilder sq = StringUtil.borrowBuilder();\n        while (!tq.isEmpty()) {\n            if (tq.matches(\"(\"))\n                sq.append(\"(\").append(tq.chompBalanced('(', ')')).append(\")\");\n            else if (tq.matches(\"[\"))\n                sq.append(\"[\").append(tq.chompBalanced('[', ']')).append(\"]\");\n            else if (tq.matchesAny(Combinators))\n                if (sq.length() > 0)\n                    break;\n                else\n                    tq.consume();\n            else\n                sq.append(tq.consume());\n        }\n        return StringUtil.releaseBuilder(sq);\n    }",
        "fix": "    private String consumeSubQuery() {\n        StringBuilder sq = StringUtil.borrowBuilder();\n        boolean seenNonCombinator = false; // eat until we hit a combinator after eating something else\n        while (!tq.isEmpty()) {\n            if (tq.matches(\"(\"))\n                sq.append(\"(\").append(tq.chompBalanced('(', ')')).append(\")\");\n            else if (tq.matches(\"[\"))\n                sq.append(\"[\").append(tq.chompBalanced('[', ']')).append(\"]\");\n            else if (tq.matchesAny(Combinators))\n                if (seenNonCombinator)\n                    break;\n                else\n                    sq.append(tq.consume());\n            else {\n                seenNonCombinator = true;\n                sq.append(tq.consume());\n            }\n        }\n        return StringUtil.releaseBuilder(sq);\n    }",
        "start": 145,
        "end": 165,
        "location": [
            153,
            156,
            157
        ],
        "fixed_class_path": "src/main/java/org/jsoup/select/QueryParser.java"
    },
    "Jsoup-116": {
        "buggy": "    public void normalize() {\n        for (int i = 0; i < size; i++) {\n            if (!isInternalKey(keys[i]))\n                keys[i] = lowerCase(keys[i]);\n        }\n    }",
        "fix": "    public void normalize() {\n        for (int i = 0; i < size; i++) {\n            if (!isInternalKey(keys[i]))\n                keys[i] = lowerCase(keys[i]);\n        }\n\n        // if we are tracking attribute source ranges, normalize those keys also\n        //noinspection unchecked\n        Map<String, Range.AttributeRange> ranges = (Map<String, Range.AttributeRange>) userData(AttrRangeKey);\n        if (ranges != null) {\n            Object[] names = ranges.keySet().toArray(); // copy to array to avoid CMEs during put\n            for (Object name : names) {\n                String normal = lowerCase((String) name);\n                if (normal.equals(name)) continue;\n                if (ranges.containsKey(normal)) {\n                    ranges.remove(name); // dedupe now that we have normalized\n                } else {\n                    Range.AttributeRange range = ranges.remove(name);\n                    ranges.put(normal, range);\n                }\n            }\n        }\n    }",
        "start": 523,
        "end": 545,
        "location": [],
        "fixed_class_path": "src/main/java/org/jsoup/nodes/Attributes.java"
    },
    "Jsoup-118": {
        "buggy": "    void initialiseParse(Reader input, String baseUri, Parser parser) {\n        Validate.notNullParam(input, \"input\");\n        Validate.notNullParam(baseUri, \"baseUri\");\n        Validate.notNull(parser);\n\n        doc = new Document(parser.defaultNamespace(), baseUri);\n        doc.parser(parser);\n        this.parser = parser;\n        settings = parser.settings();\n        reader = new CharacterReader(input);\n        trackSourceRange = parser.isTrackPosition();\n        reader.trackNewlines(parser.isTrackErrors() || trackSourceRange); // when tracking errors or source ranges, enable newline tracking for better legibility\n        currentToken = null;\n        tokeniser = new Tokeniser(this);\n        stack = new ArrayList<>(32);\n        seenTags = new HashMap<>();\n        start = new Token.StartTag(this);\n        this.baseUri = baseUri;\n    }",
        "fix": "    void initialiseParse(Reader input, String baseUri, Parser parser) {\n        Validate.notNullParam(input, \"input\");\n        Validate.notNullParam(baseUri, \"baseUri\");\n        Validate.notNull(parser);\n\n        doc = new Document(parser.defaultNamespace(), baseUri);\n        doc.parser(parser);\n        this.parser = parser;\n        settings = parser.settings();\n        reader = new CharacterReader(input);\n        trackSourceRange = parser.isTrackPosition();\n        reader.trackNewlines(parser.isTrackErrors() || trackSourceRange); // when tracking errors or source ranges, enable newline tracking for better legibility\n        tokeniser = new Tokeniser(this);\n        stack = new ArrayList<>(32);\n        seenTags = new HashMap<>();\n        start = new Token.StartTag(this);\n        currentToken = start; // init current token to the virtual start token.\n        this.baseUri = baseUri;\n    }",
        "start": 38,
        "end": 57,
        "location": [
            50
        ],
        "fixed_class_path": "src/main/java/org/jsoup/parser/TreeBuilder.java"
    },
    "Jsoup-120": {
        "buggy": "    private String consumeSubQuery() {\n        StringBuilder sq = StringUtil.borrowBuilder();\n        boolean seenNonCombinator = false; // eat until we hit a combinator after eating something else\n        while (!tq.isEmpty()) {\n            if (tq.matches(\"(\"))\n                sq.append(\"(\").append(tq.chompBalanced('(', ')')).append(\")\");\n            else if (tq.matches(\"[\"))\n                sq.append(\"[\").append(tq.chompBalanced('[', ']')).append(\"]\");\n            else if (tq.matchesAny(Combinators))\n                if (seenNonCombinator)\n                    break;\n                else\n                    sq.append(tq.consume());\n            else {\n                seenNonCombinator = true;\n                sq.append(tq.consume());\n            }\n        }\n        return StringUtil.releaseBuilder(sq);\n    }",
        "fix": "    private String consumeSubQuery() {\n        StringBuilder sq = StringUtil.borrowBuilder();\n        boolean seenClause = false; // eat until we hit a combinator after eating something else\n        while (!tq.isEmpty()) {\n            if (tq.matchesAny(Combinators)) {\n                if (seenClause)\n                    break;\n                sq.append(tq.consume());\n                continue;\n            }\n            seenClause = true;\n            if (tq.matches(\"(\"))\n                sq.append(\"(\").append(tq.chompBalanced('(', ')')).append(\")\");\n            else if (tq.matches(\"[\"))\n                sq.append(\"[\").append(tq.chompBalanced('[', ']')).append(\"]\");\n            else\n                sq.append(tq.consume());\n        }\n        return StringUtil.releaseBuilder(sq);\n    }",
        "start": 145,
        "end": 165,
        "location": [
            147,
            153,
            154,
            155,
            156,
            157,
            158,
            159,
            161
        ],
        "fixed_class_path": "src/main/java/org/jsoup/select/QueryParser.java"
    },
    "Jsoup-121": {
        "buggy": "    @Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        if (out.syntax() == Document.OutputSettings.Syntax.xml) {\n            // In XML mode, output data nodes as CDATA, so can parse as XML\n            accum\n                .append(\"<![CDATA[\")\n                .append(getWholeData())\n                .append(\"]]>\");\n        } else {\n            // In HTML, data is not escaped in return from data nodes, so \" in script, style is plain\n            accum.append(getWholeData());\n        }\n    }",
        "fix": "    @Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        /* For XML output, escape the DataNode in a CData section. The data may contain pseudo-CData content if it was\n        parsed as HTML, so don't double up Cdata. Output in polygot HTML / XHTML / XML format. */\n        final String data = getWholeData();\n        if (out.syntax() == Document.OutputSettings.Syntax.xml && !data.contains(\"<![CDATA[\")) {\n            if (hasParent() && parentNode.normalName().equals(\"script\"))\n                accum.append(\"//<![CDATA[\\n\").append(data).append(\"\\n//]]>\");\n            else if (hasParent() && parentNode.normalName().equals(\"style\"))\n                accum.append(\"/*<![CDATA[*/\\n\").append(data).append(\"\\n/*]]>*/\");\n            else\n                accum.append(\"<![CDATA[\").append(data).append(\"]]>\");\n        } else {\n            // In HTML, data is not escaped in the output of data nodes, so < and & in script, style is OK\n            accum.append(getWholeData());\n        }\n    }",
        "start": 43,
        "end": 60,
        "location": [
            45,
            46,
            47,
            48,
            49,
            50,
            52
        ],
        "fixed_class_path": "src/main/java/org/jsoup/nodes/DataNode.java"
    },
    "Lang-600": {
        "buggy": "    public static Method getMatchingMethod(final Class<?> cls, final String methodName,\n            final Class<?>... parameterTypes) {\n        Objects.requireNonNull(cls, \"cls\");\n        Validate.notEmpty(methodName, \"methodName\");\n\n        final List<Method> methods = Stream.of(cls.getDeclaredMethods())\n                .filter(method -> method.getName().equals(methodName))\n                .collect(Collectors.toList());\n\n        ClassUtils.getAllSuperclasses(cls).stream()\n                .map(Class::getDeclaredMethods)\n                .flatMap(Stream::of)\n                .filter(method -> method.getName().equals(methodName))\n                .forEach(methods::add);\n\n        for (final Method method : methods) {\n            if (Arrays.deepEquals(method.getParameterTypes(), parameterTypes)) {\n                return method;\n            }\n        }\n\n        final TreeMap<Integer, List<Method>> candidates = new TreeMap<>();\n\n        methods.stream()\n                .filter(method -> ClassUtils.isAssignable(parameterTypes, method.getParameterTypes(), true))\n                .forEach(method -> {\n                    final int distance = distance(parameterTypes, method.getParameterTypes());\n                    final List<Method> candidatesAtDistance = candidates.computeIfAbsent(distance, k -> new ArrayList<>());\n                    candidatesAtDistance.add(method);\n                });\n\n        if (candidates.isEmpty()) {\n            return null;\n        }\n\n        final List<Method> bestCandidates = candidates.values().iterator().next();\n        if (bestCandidates.size() == 1) {\n            return bestCandidates.get(0);\n        }\n\n        throw new IllegalStateException(\n                String.format(\"Found multiple candidates for method %s on class %s : %s\",\n                        methodName + Stream.of(parameterTypes).map(String::valueOf).collect(Collectors.joining(\",\", \"(\", \")\")),\n                        cls.getName(),\n                        bestCandidates.stream().map(Method::toString).collect(Collectors.joining(\",\", \"[\", \"]\")))\n        );\n    }",
        "fix": "    public static Method getMatchingMethod(final Class<?> cls, final String methodName,\n            final Class<?>... parameterTypes) {\n        Objects.requireNonNull(cls, \"cls\");\n        Validate.notEmpty(methodName, \"methodName\");\n\n        final List<Method> methods = Stream.of(cls.getDeclaredMethods())\n                .filter(method -> method.getName().equals(methodName))\n                .collect(Collectors.toList());\n\n        ClassUtils.getAllSuperclasses(cls).stream()\n                .map(Class::getDeclaredMethods)\n                .flatMap(Stream::of)\n                .filter(method -> method.getName().equals(methodName))\n                .forEach(methods::add);\n\n        for (final Method method : methods) {\n            if (Arrays.deepEquals(method.getParameterTypes(), parameterTypes)) {\n                return method;\n            }\n        }\n\n        final TreeMap<Integer, List<Method>> candidates = new TreeMap<>();\n\n        methods.stream()\n                .filter(method -> ClassUtils.isAssignable(parameterTypes, method.getParameterTypes(), true))\n                .forEach(method -> {\n                    final int distance = distance(parameterTypes, method.getParameterTypes());\n                    final List<Method> candidatesAtDistance = candidates.computeIfAbsent(distance, k -> new ArrayList<>());\n                    candidatesAtDistance.add(method);\n                });\n\n        if (candidates.isEmpty()) {\n            return null;\n        }\n\n        final List<Method> bestCandidates = candidates.values().iterator().next();\n        if (bestCandidates.size() == 1 || !Objects.equals(bestCandidates.get(0).getDeclaringClass(),\n                bestCandidates.get(1).getDeclaringClass())) {\n            return bestCandidates.get(0);\n        }\n\n        throw new IllegalStateException(\n                String.format(\"Found multiple candidates for method %s on class %s : %s\",\n                        methodName + Stream.of(parameterTypes).map(String::valueOf).collect(Collectors.joining(\",\", \"(\", \")\")),\n                        cls.getName(),\n                        bestCandidates.stream().map(Method::toString).collect(Collectors.joining(\",\", \"[\", \"]\")))\n        );\n    }",
        "start": 718,
        "end": 765,
        "location": [
            754
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/lang3/reflect/MethodUtils.java"
    },
    "Lang-606": {
        "buggy": "    public static Class<?> getRawType(final Type type, final Type assigningType) {\n        if (type instanceof Class<?>) {\n            // it is raw, no problem\n            return (Class<?>) type;\n        }\n\n        if (type instanceof ParameterizedType) {\n            // simple enough to get the raw type of a ParameterizedType\n            return getRawType((ParameterizedType) type);\n        }\n\n        if (type instanceof TypeVariable<?>) {\n            if (assigningType == null) {\n                return null;\n            }\n\n            // get the entity declaring this type variable\n            final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration();\n\n            // can't get the raw type of a method- or constructor-declared type\n            // variable\n            if (!(genericDeclaration instanceof Class<?>)) {\n                return null;\n            }\n\n            // get the type arguments for the declaring class/interface based\n            // on the enclosing type\n            final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType,\n                    (Class<?>) genericDeclaration);\n\n            // enclosingType has to be a subclass (or subinterface) of the\n            // declaring type\n            if (typeVarAssigns == null) {\n                return null;\n            }\n\n            // get the argument assigned to this type variable\n            final Type typeArgument = typeVarAssigns.get(type);\n\n            if (typeArgument == null) {\n                return null;\n            }\n\n            // get the argument for this type variable\n            return getRawType(typeArgument, assigningType);\n        }\n\n        if (type instanceof GenericArrayType) {\n            // get raw component type\n            final Class<?> rawComponentType = getRawType(((GenericArrayType) type)\n                    .getGenericComponentType(), assigningType);\n\n            // create array type from raw component type and return its class\n            return Array.newInstance(rawComponentType, 0).getClass();\n        }\n\n        // (hand-waving) this is not the method you're looking for\n        if (type instanceof WildcardType) {\n            return null;\n        }\n\n        throw new IllegalArgumentException(\"unknown type: \" + type);\n    }",
        "fix": "    public static Class<?> getRawType(final Type type, final Type assigningType) {\n        if (type instanceof Class<?>) {\n            // it is raw, no problem\n            return (Class<?>) type;\n        }\n\n        if (type instanceof ParameterizedType) {\n            // simple enough to get the raw type of a ParameterizedType\n            return getRawType((ParameterizedType) type);\n        }\n\n        if (type instanceof TypeVariable<?>) {\n            if (assigningType == null) {\n                return null;\n            }\n\n            // get the entity declaring this type variable\n            final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration();\n\n            // can't get the raw type of a method- or constructor-declared type\n            // variable\n            if (!(genericDeclaration instanceof Class<?>)) {\n                return null;\n            }\n\n            // get the type arguments for the declaring class/interface based\n            // on the enclosing type\n            final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType,\n                    (Class<?>) genericDeclaration);\n\n            // enclosingType has to be a subclass (or subinterface) of the\n            // declaring type\n            if (typeVarAssigns == null) {\n                return null;\n            }\n\n            // get the argument assigned to this type variable\n            final Type typeArgument = typeVarAssigns.get(type);\n\n            if (typeArgument == null) {\n                return null;\n            }\n\n            // get the argument for this type variable\n            return getRawType(typeArgument, assigningType);\n        }\n\n        if (type instanceof GenericArrayType) {\n            // get raw component type\n            final Class<?> rawComponentType = getRawType(((GenericArrayType) type)\n                    .getGenericComponentType(), assigningType);\n\n            // create array type from raw component type and return its class\n            return rawComponentType != null ? Array.newInstance(rawComponentType, 0).getClass() : null;\n        }\n\n        // (hand-waving) this is not the method you're looking for\n        if (type instanceof WildcardType) {\n            return null;\n        }\n\n        throw new IllegalArgumentException(\"unknown type: \" + type);\n    }",
        "start": 752,
        "end": 814,
        "location": [
            805
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java"
    },
    "Lang-609": {
        "buggy": "    protected void appendFieldsIn(final Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        // The elements in the returned array are not sorted and are not in any particular order.\n        final Field[] fields = ArraySorter.sort(clazz.getDeclaredFields(), Comparator.comparing(Field::getName));\n        AccessibleObject.setAccessible(fields, true);\n        for (final Field field : fields) {\n            final String fieldName = field.getName();\n            if (this.accept(field)) {\n                // Warning: Field.get(Object) creates wrappers objects for primitive types.\n                final Object fieldValue = Reflection.getUnchecked(field, getObject());\n                if (!excludeNullValues || fieldValue != null) {\n                    this.append(fieldName, fieldValue, !field.isAnnotationPresent(ToStringSummary.class));\n                }\n            }\n        }\n    }",
        "fix": "    protected void appendFieldsIn(final Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        // The elements in the returned array are not sorted and are not in any particular order.\n        final Field[] fields = ArraySorter.sort(clazz.getDeclaredFields(), Comparator.comparing(Field::getName));\n        AccessibleObject.setAccessible(fields, true);\n        for (final Field field : fields) {\n            final String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    final Object fieldValue = this.getValue(field);\n                    if (!excludeNullValues || fieldValue != null) {\n                        this.append(fieldName, fieldValue, !field.isAnnotationPresent(ToStringSummary.class));\n                    }\n                } catch (final IllegalAccessException e) {\n                    // this can't happen. Would get a Security exception instead throw a runtime exception in case the\n                    // impossible happens.\n                    throw new IllegalStateException(e);\n                }\n            }\n        }\n    }",
        "start": 649,
        "end": 674,
        "location": [
            660,
            661,
            662,
            663
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java"
    },
    "Lang-611": {
        "buggy": "    public static Number createNumber(final String str) {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Need to deal with all possible hex prefixes here\n        final String[] hexPrefixes = {\"0x\", \"0X\", \"#\"};\n        final int length = str.length();\n        final int offset = str.charAt(0) == '+' || str.charAt(0) == '-' ? 1 : 0;\n        int pfxLen = 0;\n        for (final String pfx : hexPrefixes) {\n            if (str.startsWith(pfx, offset)) {\n                pfxLen += pfx.length() + offset;\n                break;\n            }\n        }\n        if (pfxLen > 0) { // we have a hex number\n            char firstSigDigit = 0; // strip leading zeroes\n            for (int i = pfxLen; i < length; i++) {\n                firstSigDigit = str.charAt(i);\n                if (firstSigDigit != '0') {\n                    break;\n                }\n                pfxLen++;\n            }\n            final int hexDigits = length - pfxLen;\n            if (hexDigits > 16 || hexDigits == 16 && firstSigDigit > '7') { // too many for Long\n                return createBigInteger(str);\n            }\n            if (hexDigits > 8 || hexDigits == 8 && firstSigDigit > '7') { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }\n        final char lastChar = str.charAt(length - 1);\n        final String mant;\n        final String dec;\n        final String exp;\n        final int decPos = str.indexOf('.');\n        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n        // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n\n        // Detect if the return type has been requested\n        final boolean requestType = !Character.isDigit(lastChar) && lastChar != '.';\n        if (decPos > -1) { // there is a decimal point\n            if (expPos > -1) { // there is an exponent\n                if (expPos < decPos || expPos > length) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                // No exponent, but there may be a type character to remove\n                dec = str.substring(decPos + 1, requestType ? length - 1 : length);\n            }\n            mant = getMantissa(str, decPos);\n        } else {\n            if (expPos > -1) {\n                if (expPos > length) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = getMantissa(str, expPos);\n            } else {\n                // No decimal, no exponent, but there may be a type character to remove\n                mant = getMantissa(str, requestType ? length - 1 : length);\n            }\n            dec = null;\n        }\n        if (requestType) {\n            if (expPos > -1 && expPos < length - 1) {\n                exp = str.substring(expPos + 1, length - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type.\n            final String numeric = str.substring(0, length - 1);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (!numeric.isEmpty() && numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (final NumberFormatException ignored) {\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        final Float f = createFloat(str);\n                        if (!(f.isInfinite() || f.floatValue() == 0.0F && !isZero(mant, dec))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (final NumberFormatException ignored) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        final Double d = createDouble(str);\n                        if (!(d.isInfinite() || d.doubleValue() == 0.0D && !isZero(mant, dec))) {\n                            return d;\n                        }\n                    } catch (final NumberFormatException ignored) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (final NumberFormatException ignored) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        }\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (expPos > -1 && expPos < length - 1) {\n            exp = str.substring(expPos + 1);\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) { // no decimal point and no exponent\n            //Must be an Integer, Long, Biginteger\n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException ignored) {\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (final NumberFormatException ignored) {\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n        }\n\n        //Must be a Float, Double, BigDecimal\n        try {\n            final Float f = createFloat(str);\n            final Double d = createDouble(str);\n            if (!f.isInfinite()\n                    && !(f.floatValue() == 0.0F && !isZero(mant, dec))\n                    && f.toString().equals(d.toString())) {\n                return f;\n            }\n            if (!d.isInfinite() && !(d.doubleValue() == 0.0D && !isZero(mant, dec))) {\n                final BigDecimal b = createBigDecimal(str);\n                if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) == 0) {\n                    return d;\n                }\n                return b;\n            }\n        } catch (final NumberFormatException ignored) {\n            // ignore the bad number\n        }\n        return createBigDecimal(str);\n    }",
        "fix": "    public static Number createNumber(final String str) {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Need to deal with all possible hex prefixes here\n        final String[] hexPrefixes = {\"0x\", \"0X\", \"#\"};\n        final int length = str.length();\n        final int offset = str.charAt(0) == '+' || str.charAt(0) == '-' ? 1 : 0;\n        int pfxLen = 0;\n        for (final String pfx : hexPrefixes) {\n            if (str.startsWith(pfx, offset)) {\n                pfxLen += pfx.length() + offset;\n                break;\n            }\n        }\n        if (pfxLen > 0) { // we have a hex number\n            char firstSigDigit = 0; // strip leading zeroes\n            for (int i = pfxLen; i < length; i++) {\n                firstSigDigit = str.charAt(i);\n                if (firstSigDigit != '0') {\n                    break;\n                }\n                pfxLen++;\n            }\n            final int hexDigits = length - pfxLen;\n            if (hexDigits > 16 || hexDigits == 16 && firstSigDigit > '7') { // too many for Long\n                return createBigInteger(str);\n            }\n            if (hexDigits > 8 || hexDigits == 8 && firstSigDigit > '7') { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }\n        final char lastChar = str.charAt(length - 1);\n        final String mant;\n        final String dec;\n        final String exp;\n        final int decPos = str.indexOf('.');\n        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n        // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n\n        // Detect if the return type has been requested\n        final boolean requestType = !Character.isDigit(lastChar) && lastChar != '.';\n        if (decPos > -1) { // there is a decimal point\n            if (expPos > -1) { // there is an exponent\n                if (expPos <= decPos || expPos > length) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                // No exponent, but there may be a type character to remove\n                dec = str.substring(decPos + 1, requestType ? length - 1 : length);\n            }\n            mant = getMantissa(str, decPos);\n        } else {\n            if (expPos > -1) {\n                if (expPos > length) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = getMantissa(str, expPos);\n            } else {\n                // No decimal, no exponent, but there may be a type character to remove\n                mant = getMantissa(str, requestType ? length - 1 : length);\n            }\n            dec = null;\n        }\n        if (requestType) {\n            if (expPos > -1 && expPos < length - 1) {\n                exp = str.substring(expPos + 1, length - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type.\n            final String numeric = str.substring(0, length - 1);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (!numeric.isEmpty() && numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (final NumberFormatException ignored) {\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        final Float f = createFloat(str);\n                        if (!(f.isInfinite() || f.floatValue() == 0.0F && !isZero(mant, dec))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (final NumberFormatException ignored) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        final Double d = createDouble(str);\n                        if (!(d.isInfinite() || d.doubleValue() == 0.0D && !isZero(mant, dec))) {\n                            return d;\n                        }\n                    } catch (final NumberFormatException ignored) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (final NumberFormatException ignored) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        }\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (expPos > -1 && expPos < length - 1) {\n            exp = str.substring(expPos + 1);\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) { // no decimal point and no exponent\n            //Must be an Integer, Long, Biginteger\n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException ignored) {\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (final NumberFormatException ignored) {\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n        }\n\n        //Must be a Float, Double, BigDecimal\n        try {\n            final Float f = createFloat(str);\n            final Double d = createDouble(str);\n            if (!f.isInfinite()\n                    && !(f.floatValue() == 0.0F && !isZero(mant, dec))\n                    && f.toString().equals(d.toString())) {\n                return f;\n            }\n            if (!d.isInfinite() && !(d.doubleValue() == 0.0D && !isZero(mant, dec))) {\n                final BigDecimal b = createBigDecimal(str);\n                if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) == 0) {\n                    return d;\n                }\n                return b;\n            }\n        } catch (final NumberFormatException ignored) {\n            // ignore the bad number\n        }\n        return createBigDecimal(str);\n    }",
        "start": 315,
        "end": 485,
        "location": [
            364
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java"
    },
    "Lang-613": {
        "buggy": "    @SuppressWarnings(\"resource\") // inputStream is managed by the caller\n    public static <T> T deserialize(final InputStream inputStream) {\n        Objects.requireNonNull(inputStream, \"inputStream\");\n        try (ObjectInputStream in = new ObjectInputStream(inputStream)) {\n            @SuppressWarnings(\"unchecked\")\n            final T obj = (T) in.readObject();\n            return obj;\n        } catch (final ClassNotFoundException | IOException ex) {\n            throw new SerializationException(ex);\n        }\n    }",
        "fix": "    @SuppressWarnings(\"resource\") // inputStream is managed by the caller\n    public static <T> T deserialize(final InputStream inputStream) {\n        Objects.requireNonNull(inputStream, \"inputStream\");\n        try (ObjectInputStream in = new ObjectInputStream(inputStream)) {\n            @SuppressWarnings(\"unchecked\")\n            final T obj = (T) in.readObject();\n            return obj;\n        } catch (final ClassNotFoundException | IOException | NegativeArraySizeException ex) {\n            throw new SerializationException(ex);\n        }\n    }",
        "start": 203,
        "end": 213,
        "location": [
            210
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/lang3/SerializationUtils.java"
    },
    "Lang-614": {
        "buggy": "    private static String getMantissa(final String str, final int stopPos) {\n        final char firstChar = str.charAt(0);\n        final boolean hasSign = firstChar == '-' || firstChar == '+';\n\n        return hasSign ? str.substring(1, stopPos) : str.substring(0, stopPos);\n    }",
        "fix": "    private static String getMantissa(final String str, final int stopPos) {\n         final char firstChar = str.charAt(0);\n         final boolean hasSign = firstChar == '-' || firstChar == '+';\n         final int length = str.length();\n         if (length <= (hasSign ? 1 : 0) || length < stopPos) {\n             throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n         return hasSign ? str.substring(1, stopPos) : str.substring(0, stopPos);\n    }",
        "start": 497,
        "end": 505,
        "location": [
            498,
            499,
            501
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java"
    }
}