{
    "Cli-251": {
        "buggy": "    private boolean isJavaProperty(final String token) {\n        final String opt = token.substring(0, 1);\n        final Option option = options.getOption(opt);\n\n        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n    }",
        "fix": "    private boolean isJavaProperty(final String token) {\n        final String opt = token.isEmpty() ? null : token.substring(0, 1);\n        final Option option = options.getOption(opt);\n\n        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n    }",
        "start": 582,
        "end": 587,
        "location": [
            583
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/cli/DefaultParser.java"
    },
    "Cli-253": {
        "buggy": "    private boolean isJavaProperty(final String token) {\n        final String opt = token.substring(0, 1);\n        final Option option = options.getOption(opt);\n\n        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n    }",
        "fix": "    private boolean isJavaProperty(final String token) {\n        final String opt = token.isEmpty() ? null : token.substring(0, 1);\n        final Option option = options.getOption(opt);\n\n        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n    }",
        "start": 582,
        "end": 587,
        "location": [
            583
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/cli/DefaultParser.java"
    },
    "Cli-254": {
        "buggy": "    private boolean isJavaProperty(final String token) {\n        final String opt = token.substring(0, 1);\n        final Option option = options.getOption(opt);\n\n        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n    }",
        "fix": "    private boolean isJavaProperty(final String token) {\n        final String opt = token.isEmpty() ? null : token.substring(0, 1);\n        final Option option = options.getOption(opt);\n\n        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n    }",
        "start": 582,
        "end": 587,
        "location": [
            583
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/cli/DefaultParser.java"
    },
    "Cli-257": {
        "buggy": "    private void checkRequiredArgs() throws ParseException {\n        if (currentOption != null && currentOption.requiresArg()) {\n            throw new MissingArgumentException(currentOption);\n        }\n    }",
        "fix": "    private void checkRequiredArgs() throws ParseException {\n        if (currentOption != null && currentOption.requiresArg()) {\n            if (isJavaProperty(currentOption.getKey()) && currentOption.getValuesList().size() == 1) {\n                return;\n            }\n            throw new MissingArgumentException(currentOption);\n        }\n    }",
        "start": 229,
        "end": 236,
        "location": [],
        "fixed_class_path": "src/main/java/org/apache/commons/cli/DefaultParser.java"
    },
    "Codec-161": {
        "buggy": "    public String encode(String input, final Languages.LanguageSet languageSet) {\n        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);\n        // rules common across many (all) languages\n        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, \"common\");\n        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages\n        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);\n\n        // tidy the input\n        // lower case is a locale-dependent operation\n        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();\n\n        if (this.nameType == NameType.GENERIC) {\n            if (input.startsWith(\"d'\")) { // check for d'\n                final String remainder = input.substring(2);\n                final String combined = \"d\" + remainder;\n                return \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\";\n            }\n            for (final String l : NAME_PREFIXES.get(this.nameType)) {\n                // handle generic prefixes\n                if (input.startsWith(l + \" \")) {\n                    // check for any prefix in the words list\n                    final String remainder = input.substring(l.length() + 1); // input without the prefix\n                    final String combined = l + remainder; // input with prefix without space\n                    return \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\";\n                }\n            }\n        }\n\n        final List<String> words = Arrays.asList(input.split(\"\\\\s+\"));\n        final List<String> words2 = new ArrayList<>();\n\n        // special-case handling of word prefixes based upon the name type\n        switch (this.nameType) {\n        case SEPHARDIC:\n            words.forEach(aWord -> {\n                final String[] parts = aWord.split(\"'\");\n                words2.add(parts[parts.length - 1]);\n            });\n            words2.removeAll(NAME_PREFIXES.get(this.nameType));\n            break;\n        case ASHKENAZI:\n            words2.addAll(words);\n            words2.removeAll(NAME_PREFIXES.get(this.nameType));\n            break;\n        case GENERIC:\n            words2.addAll(words);\n            break;\n        default:\n            throw new IllegalStateException(\"Unreachable case: \" + this.nameType);\n        }\n\n        if (this.concat) {\n            // concat mode enabled\n            input = join(words2, \" \");\n        } else if (words2.size() == 1) {\n            // not a multi-word name\n            input = words.iterator().next();\n        } else {\n            // encode each word in a multi-word name separately (normally used for approx matches)\n            final StringBuilder result = new StringBuilder();\n            words2.forEach(word -> result.append(\"-\").append(encode(word)));\n            // return the result without the leading \"-\"\n            return result.substring(1);\n        }\n\n        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);\n\n        // loop over each char in the input - we will handle the increment manually\n        for (int i = 0; i < input.length();) {\n            final RulesApplication rulesApplication =\n                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();\n            i = rulesApplication.getI();\n            phonemeBuilder = rulesApplication.getPhonemeBuilder();\n        }\n\n        // Apply the general rules\n        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);\n        // Apply the language-specific rules\n        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);\n\n        return phonemeBuilder.makeString();\n    }",
        "fix": "    public String encode(String input, final Languages.LanguageSet languageSet) {\n        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);\n        // rules common across many (all) languages\n        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, \"common\");\n        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages\n        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);\n\n        // tidy the input\n        // lower case is a locale-dependent operation\n        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();\n\n        if (this.nameType == NameType.GENERIC) {\n            if (input.startsWith(\"d'\")) { // check for d'\n                final String remainder = input.substring(2);\n                final String combined = \"d\" + remainder;\n                return \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\";\n            }\n            for (final String l : NAME_PREFIXES.get(this.nameType)) {\n                // handle generic prefixes\n                if (input.startsWith(l + \" \")) {\n                    // check for any prefix in the words list\n                    final String remainder = input.substring(l.length() + 1); // input without the prefix\n                    final String combined = l + remainder; // input with prefix without space\n                    return \"(\" + encode(remainder) + \")-(\" + encode(combined) + \")\";\n                }\n            }\n        }\n\n        final List<String> words = Arrays.asList(input.split(\"\\\\s+\"));\n        final List<String> words2 = new ArrayList<>();\n\n        // special-case handling of word prefixes based upon the name type\n        switch (this.nameType) {\n        case SEPHARDIC:\n            words.forEach(aWord -> {\n                final String[] parts = aWord.split(\"'\", -1);\n                words2.add(parts[parts.length - 1]);\n            });\n            words2.removeAll(NAME_PREFIXES.get(this.nameType));\n            break;\n        case ASHKENAZI:\n            words2.addAll(words);\n            words2.removeAll(NAME_PREFIXES.get(this.nameType));\n            break;\n        case GENERIC:\n            words2.addAll(words);\n            break;\n        default:\n            throw new IllegalStateException(\"Unreachable case: \" + this.nameType);\n        }\n\n        if (this.concat) {\n            // concat mode enabled\n            input = join(words2, \" \");\n        } else if (words2.size() == 1) {\n            // not a multi-word name\n            input = words.iterator().next();\n        } else if (!words2.isEmpty()) {\n            // encode each word in a multi-word name separately (normally used for approx matches)\n            final StringBuilder result = new StringBuilder();\n            words2.forEach(word -> result.append(\"-\").append(encode(word)));\n            // return the result without the leading \"-\"\n            return result.substring(1);\n        }\n\n        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);\n\n        // loop over each char in the input - we will handle the increment manually\n        for (int i = 0; i < input.length();) {\n            final RulesApplication rulesApplication =\n                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();\n            i = rulesApplication.getI();\n            phonemeBuilder = rulesApplication.getPhonemeBuilder();\n        }\n\n        // Apply the general rules\n        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);\n        // Apply the language-specific rules\n        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);\n\n        return phonemeBuilder.makeString();\n    }",
        "start": 377,
        "end": 458,
        "location": [
            412,
            434
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java"
    },
    "Codec-163": {
        "buggy": "    public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes, final boolean strict) {\n        if (bytes == null) {\n            return null;\n        }\n        if (printable == null) {\n            printable = PRINTABLE_CHARS;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        final int bytesLength = bytes.length;\n\n        if (strict) {\n            int pos = 1;\n            // encode up to buffer.length - 3, the last three octets will be treated\n            // separately for simplification of note #3\n            for (int i = 0; i < bytesLength - 3; i++) {\n                final int b = getUnsignedOctet(i, bytes);\n                if (pos < SAFE_LENGTH) {\n                    // up to this length it is safe to add any byte, encoded or not\n                    pos += encodeByte(b, !printable.get(b), buffer);\n                } else {\n                    // rule #3: whitespace at the end of a line *must* be encoded\n                    encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);\n\n                    // rule #5: soft line break\n                    buffer.write(ESCAPE_CHAR);\n                    buffer.write(CR);\n                    buffer.write(LF);\n                    pos = 1;\n                }\n            }\n\n            // rule #3: whitespace at the end of a line *must* be encoded\n            // if we would do a soft break line after this octet, encode whitespace\n            int b = getUnsignedOctet(bytesLength - 3, bytes);\n            boolean encode = !printable.get(b) || isWhitespace(b) && pos > SAFE_LENGTH - 5;\n            pos += encodeByte(b, encode, buffer);\n\n            // note #3: '=' *must not* be the ultimate or penultimate character\n            // simplification: if < 6 bytes left, do a soft line break as we may need\n            //                 exactly 6 bytes space for the last 2 bytes\n            if (pos > SAFE_LENGTH - 2) {\n                buffer.write(ESCAPE_CHAR);\n                buffer.write(CR);\n                buffer.write(LF);\n            }\n            for (int i = bytesLength - 2; i < bytesLength; i++) {\n                b = getUnsignedOctet(i, bytes);\n                // rule #3: trailing whitespace shall be encoded\n                encode = !printable.get(b) || i > bytesLength - 2 && isWhitespace(b);\n                encodeByte(b, encode, buffer);\n            }\n        } else {\n            for (final byte c : bytes) {\n                int b = c;\n                if (b < 0) {\n                    b = 256 + b;\n                }\n                if (printable.get(b)) {\n                    buffer.write(b);\n                } else {\n                    encodeQuotedPrintable(b, buffer);\n                }\n            }\n        }\n        return buffer.toByteArray();\n    }",
        "fix": "    public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes, final boolean strict) {\n        if (bytes == null) {\n            return null;\n        }\n        if (printable == null) {\n            printable = PRINTABLE_CHARS;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        final int bytesLength = bytes.length;\n\n        if (strict) {\n            if (bytesLength < MIN_BYTES) {\n                return null;\n            }\n\n            int pos = 1;\n            // encode up to buffer.length - 3, the last three octets will be treated\n            // separately for simplification of note #3\n            for (int i = 0; i < bytesLength - 3; i++) {\n                final int b = getUnsignedOctet(i, bytes);\n                if (pos < SAFE_LENGTH) {\n                    // up to this length it is safe to add any byte, encoded or not\n                    pos += encodeByte(b, !printable.get(b), buffer);\n                } else {\n                    // rule #3: whitespace at the end of a line *must* be encoded\n                    encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);\n\n                    // rule #5: soft line break\n                    buffer.write(ESCAPE_CHAR);\n                    buffer.write(CR);\n                    buffer.write(LF);\n                    pos = 1;\n                }\n            }\n\n            // rule #3: whitespace at the end of a line *must* be encoded\n            // if we would do a soft break line after this octet, encode whitespace\n            int b = getUnsignedOctet(bytesLength - 3, bytes);\n            boolean encode = !printable.get(b) || isWhitespace(b) && pos > SAFE_LENGTH - 5;\n            pos += encodeByte(b, encode, buffer);\n\n            // note #3: '=' *must not* be the ultimate or penultimate character\n            // simplification: if < 6 bytes left, do a soft line break as we may need\n            //                 exactly 6 bytes space for the last 2 bytes\n            if (pos > SAFE_LENGTH - 2) {\n                buffer.write(ESCAPE_CHAR);\n                buffer.write(CR);\n                buffer.write(LF);\n            }\n            for (int i = bytesLength - 2; i < bytesLength; i++) {\n                b = getUnsignedOctet(i, bytes);\n                // rule #3: trailing whitespace shall be encoded\n                encode = !printable.get(b) || i > bytesLength - 2 && isWhitespace(b);\n                encodeByte(b, encode, buffer);\n            }\n        } else {\n            for (final byte c : bytes) {\n                int b = c;\n                if (b < 0) {\n                    b = 256 + b;\n                }\n                if (printable.get(b)) {\n                    buffer.write(b);\n                } else {\n                    encodeQuotedPrintable(b, buffer);\n                }\n            }\n        }\n        return buffer.toByteArray();\n    }",
        "start": 205,
        "end": 274,
        "location": [],
        "fixed_class_path": "src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java"
    },
    "Codec-164": {
        "buggy": "    @Override\n    public final String encode(String name) {\n        // Bulletproof for trivial input - NINO\n        if (name == null || EMPTY.equalsIgnoreCase(name) || SPACE.equalsIgnoreCase(name) || name.length() == 1) {\n            return EMPTY;\n        }\n\n        // Preprocessing\n        name = cleanName(name);\n\n        // BEGIN: Actual encoding part of the algorithm...\n        // 1. Delete all vowels unless the vowel begins the word\n        name = removeVowels(name);\n\n        // 2. Remove second consonant from any double consonant\n        name = removeDoubleConsonants(name);\n\n        // 3. Reduce codex to 6 letters by joining the first 3 and last 3 letters\n        name = getFirst3Last3(name);\n\n        return name;\n    }",
        "fix": "    @Override\n    public final String encode(String name) {\n        // Bulletproof for trivial input - NINO\n        if (name == null || EMPTY.equalsIgnoreCase(name) || SPACE.equalsIgnoreCase(name) || name.length() == 1) {\n            return EMPTY;\n        }\n\n        // Preprocessing\n        name = cleanName(name);\n\n        // Bulletproof if name becomes empty after cleanName(name)\n        if (SPACE.equals(name) || name.isEmpty()) {\n            return EMPTY;\n        }\n\n        // BEGIN: Actual encoding part of the algorithm...\n        // 1. Delete all vowels unless the vowel begins the word\n        name = removeVowels(name);\n\n        // Bulletproof if name becomes empty after removeVowels(name)\n        if (SPACE.equals(name) || name.isEmpty()) {\n            return EMPTY;\n        }\n\n        // 2. Remove second consonant from any double consonant\n        name = removeDoubleConsonants(name);\n\n        // 3. Reduce codex to 6 letters by joining the first 3 and last 3 letters\n        name = getFirst3Last3(name);\n\n        return name;\n    }",
        "start": 119,
        "end": 150,
        "location": [],
        "fixed_class_path": "src/main/java/org/apache/commons/codec/language/MatchRatingApproachEncoder.java"
    },
    "Codec-166": {
        "buggy": "    char getMappingCode(final char c) {\n        if (!Character.isLetter(c)) {\n            return 0;\n        }\n        return this.soundexMapping[Character.toUpperCase(c) - 'A'];\n    }",
        "fix": "    char getMappingCode(final char c) {\n        if (!Character.isLetter(c)) {\n            return 0;\n        }\n        final int index = Character.toUpperCase(c) - 'A';\n        if (index < 0 || index >= this.soundexMapping.length) {\n            return 0;\n        }\n        return this.soundexMapping[index];\n    }",
        "start": 172,
        "end": 181,
        "location": [
            176
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/codec/language/RefinedSoundex.java"
    },
    "Compress-461": {
        "buggy": "    private void pushback(final byte[] buf, final int offset, final int length) throws IOException {\n        ((PushbackInputStream) inputStream).unread(buf, offset, length);\n        pushedBackBytes(length);\n    }",
        "fix": "    private void pushback(final byte[] buf, final int offset, final int length) throws IOException {\n        if (offset < 0) {\n            // Instead of ArrayIndexOutOfBoundsException\n            throw new IOException(String.format(\"Negative offset %,d into buffer\", offset));\n        }\n        ((PushbackInputStream) inputStream).unread(buf, offset, length);\n        pushedBackBytes(length);\n    }",
        "start": 985,
        "end": 993,
        "location": [],
        "fixed_class_path": "src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java"
    },
    "Compress-465": {
        "buggy": "    public boolean isFile() {\n        if (file != null) {\n            return Files.isRegularFile(file, linkOptions);\n        }\n        if (linkFlag == LF_OLDNORM || linkFlag == LF_NORMAL) {\n            return true;\n        }\n        return !getName().endsWith(\"/\");\n    }",
        "fix": "    public boolean isFile() {\n        if (file != null) {\n            return Files.isRegularFile(file, linkOptions);\n        }\n        if (linkFlag == LF_OLDNORM || linkFlag == LF_NORMAL) {\n            return true;\n        }\n        return linkFlag != LF_DIR && !getName().endsWith(\"/\");\n    }",
        "start": 1237,
        "end": 1245,
        "location": [
            1244
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java"
    },
    "Compress-469": {
        "buggy": "    public static boolean isDosTime(final long time) {\n        return time <= UPPER_DOSTIME_BOUND && javaToDosTime(time) != DOSTIME_BEFORE_1980;\n    }",
        "fix": "    public static boolean isDosTime(final long time) {\n        return time <= UPPER_DOSTIME_BOUND &&\n                (time == DOSTIME_BEFORE_1980_AS_JAVA_TIME || javaToDosTime(time) != DOSTIME_BEFORE_1980);\n    }",
        "start": 235,
        "end": 238,
        "location": [
            236
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/compress/archivers/zip/ZipUtil.java"
    },
    "Compress-476": {
        "buggy": "    private boolean readFirstLocalFileHeader() throws IOException {\n        try {\n            // for empty archive, we may get only EOCD size:\n            final byte[] header = new byte[Math.min(LFH_LEN, ZipFile.MIN_EOCD_SIZE)];\n            readFully(header);\n            READ_LOOP: for (int i = 0; ; ) {\n                for (int j = 0; i <= PREAMBLE_GARBAGE_MAX_SIZE - 4 && j <= header.length - 4; ++j, ++i) {\n                    final ZipLong sig = new ZipLong(header, j);\n                    if (\n                            sig.equals(ZipLong.LFH_SIG) ||\n                            sig.equals(ZipLong.SINGLE_SEGMENT_SPLIT_MARKER) ||\n                            sig.equals(ZipLong.DD_SIG)) {\n                        // regular archive containing at least one entry:\n                        System.arraycopy(header, j, header, 0, header.length - j);\n                        readFully(header, header.length - j);\n                        break READ_LOOP;\n                    }\n                    if (\n                            sig.equals(new ZipLong(ZipArchiveOutputStream.EOCD_SIG))\n                    ) {\n                        // empty archive:\n                        pushback(header, j, header.length - j);\n                        return false;\n                    }\n                }\n                if (i >= PREAMBLE_GARBAGE_MAX_SIZE - 4) {\n                    throw new ZipException(\"Cannot find zip signature within the first \" + PREAMBLE_GARBAGE_MAX_SIZE + \" bytes\");\n                }\n                System.arraycopy(header, header.length - 3, header, 0, 3);\n                readFully(header, 3);\n            }\n            System.arraycopy(header, 0, lfhBuf, 0, header.length);\n            readFully(lfhBuf, header.length);\n        } catch (final EOFException ex) {\n            throw new ZipException(\"Cannot find zip signature within the file\");\n        }\n        final ZipLong sig = new ZipLong(lfhBuf);\n\n        if (!skipSplitSig && sig.equals(ZipLong.DD_SIG)) {\n            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.SPLITTING);\n        }\n\n        // the split ZIP signature(08074B50) should only be skipped when the skipSplitSig is set\n        if (sig.equals(ZipLong.SINGLE_SEGMENT_SPLIT_MARKER) || sig.equals(ZipLong.DD_SIG)) {\n            // Just skip over the marker.\n            System.arraycopy(lfhBuf, 4, lfhBuf, 0, lfhBuf.length - 4);\n            readFully(lfhBuf, lfhBuf.length - 4);\n        }\n        return true;\n    }",
        "fix": "    private boolean readFirstLocalFileHeader() throws IOException {\n        // for empty archive, we may get only EOCD size:\n        final byte[] header = new byte[Math.min(LFH_LEN, ZipFile.MIN_EOCD_SIZE)];\n        readFully(header);\n        try {\n            READ_LOOP: for (int i = 0; ; ) {\n                for (int j = 0; i <= PREAMBLE_GARBAGE_MAX_SIZE - 4 && j <= header.length - 4; ++j, ++i) {\n                    final ZipLong sig = new ZipLong(header, j);\n                    if (\n                            sig.equals(ZipLong.LFH_SIG) ||\n                            sig.equals(ZipLong.SINGLE_SEGMENT_SPLIT_MARKER) ||\n                            sig.equals(ZipLong.DD_SIG)) {\n                        // regular archive containing at least one entry:\n                        System.arraycopy(header, j, header, 0, header.length - j);\n                        readFully(header, header.length - j);\n                        break READ_LOOP;\n                    }\n                    if (\n                            sig.equals(new ZipLong(ZipArchiveOutputStream.EOCD_SIG))\n                    ) {\n                        // empty archive:\n                        pushback(header, j, header.length - j);\n                        return false;\n                    }\n                }\n                if (i >= PREAMBLE_GARBAGE_MAX_SIZE - 4) {\n                    throw new ZipException(\"Cannot find zip signature within the first \" + PREAMBLE_GARBAGE_MAX_SIZE + \" bytes\");\n                }\n                System.arraycopy(header, header.length - 3, header, 0, 3);\n                readFully(header, 3);\n            }\n            System.arraycopy(header, 0, lfhBuf, 0, header.length);\n            readFully(lfhBuf, header.length);\n        } catch (final EOFException ex) {\n            throw new ZipException(\"Cannot find zip signature within the file\");\n        }\n        final ZipLong sig = new ZipLong(lfhBuf);\n\n        if (!skipSplitSig && sig.equals(ZipLong.DD_SIG)) {\n            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.SPLITTING);\n        }\n\n        // the split ZIP signature(08074B50) should only be skipped when the skipSplitSig is set\n        if (sig.equals(ZipLong.SINGLE_SEGMENT_SPLIT_MARKER) || sig.equals(ZipLong.DD_SIG)) {\n            // Just skip over the marker.\n            System.arraycopy(lfhBuf, 4, lfhBuf, 0, lfhBuf.length - 4);\n            readFully(lfhBuf, lfhBuf.length - 4);\n        }\n        return true;\n    }",
        "start": 1014,
        "end": 1063,
        "location": [
            1016,
            1017,
            1018
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java"
    },
    "Jsoup-98": {
        "buggy": "    public static String escape(String string) {\n        return escape(string, DefaultOutput);\n    }",
        "fix": "    public static String escape(String string) {\n        if (DefaultOutput == null)\n            DefaultOutput = new OutputSettings();\n        return escape(string, DefaultOutput);\n    }",
        "start": 159,
        "end": 163,
        "location": [],
        "fixed_class_path": "src/main/java/org/jsoup/nodes/Entities.java"
    },
    "Jsoup-101": {
        "buggy": "    private boolean isInlineable(Document.OutputSettings out) {\n        if (!tag.isInline())\n            return false;\n        return (parent() == null || parent().isBlock())\n            && !isEffectivelyFirst()\n            && !out.outline();\n    }",
        "fix": "    private boolean isInlineable(Document.OutputSettings out) {\n        if (!tag.isInline())\n            return false;\n        return (parent() == null || parent().isBlock())\n            && !isEffectivelyFirst()\n            && !out.outline()\n            && !isNode(\"br\");\n    }",
        "start": 1848,
        "end": 1856,
        "location": [
            1853
        ],
        "fixed_class_path": "src/main/java/org/jsoup/nodes/Element.java"
    },
    "Jsoup-105": {
        "buggy": "    private boolean isFormatAsBlock(Document.OutputSettings out) {\n        return tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline();\n    }",
        "fix": "    private boolean isFormatAsBlock(Document.OutputSettings out) {\n        return tag.isBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline();\n    }",
        "start": 1845,
        "end": 1848,
        "location": [
            1846
        ],
        "fixed_class_path": "src/main/java/org/jsoup/nodes/Element.java"
    },
    "Jsoup-107": {
        "buggy": "    URL build() {\n        try {\n            // use the URI class to encode non-ascii in path\n            URI uri = new URI(\n                u.getProtocol(),\n                u.getUserInfo(),\n                IDN.toASCII(decodePart(u.getHost())), // puny-code\n                u.getPort(),\n                decodePart(u.getPath()),\n                null, null // query and fragment appended later so as not to encode\n            );\n\n            String normUrl = uri.toASCIIString();\n            if (q != null || u.getRef() != null) {\n                StringBuilder sb = StringUtil.borrowBuilder().append(normUrl);\n                if (q != null) {\n                    sb.append('?');\n                    appendToAscii(StringUtil.releaseBuilder(q), true, sb);\n                }\n                if (u.getRef() != null) {\n                    sb.append('#');\n                    appendToAscii(u.getRef(), false, sb);\n                }\n                normUrl = StringUtil.releaseBuilder(sb);\n            }\n            u =  new URL(normUrl);\n            return u;\n        } catch (MalformedURLException | URISyntaxException | UnsupportedEncodingException e) {\n            // we assert here so that any incomplete normalization issues can be caught in devel. but in practise,\n            // the remote end will be able to handle it, so in prod we just pass the original URL.\n            // The UnsupportedEncodingException would never happen as always UTF8\n            assert Validate.assertFail(e.toString());\n            return u;\n        }\n    }",
        "fix": "    URL build() {\n        try {\n            // use the URI class to encode non-ascii in path\n            URI uri = new URI(\n                u.getProtocol(),\n                u.getUserInfo(),\n                IDN.toASCII(decodePart(u.getHost())), // puny-code\n                u.getPort(),\n                null, null, null // path, query and fragment appended later so as not to encode\n            );\n\n            StringBuilder normUrl = StringUtil.borrowBuilder().append(uri.toASCIIString());\n            appendToAscii(u.getPath(), false, normUrl);\n            if (q != null) {\n                normUrl.append('?');\n                appendToAscii(StringUtil.releaseBuilder(q), true, normUrl);\n            }\n            if (u.getRef() != null) {\n                normUrl.append('#');\n                appendToAscii(u.getRef(), false, normUrl);\n            }\n            u = new URL(StringUtil.releaseBuilder(normUrl));\n            return u;\n        } catch (MalformedURLException | URISyntaxException | UnsupportedEncodingException e) {\n            // we assert here so that any incomplete normalization issues can be caught in devel. but in practise,\n            // the remote end will be able to handle it, so in prod we just pass the original URL.\n            // The UnsupportedEncodingException would never happen as always UTF8\n            assert Validate.assertFail(e.toString());\n            return u;\n        }\n    }",
        "start": 32,
        "end": 63,
        "location": [
            40,
            41,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            57
        ],
        "fixed_class_path": "src/main/java/org/jsoup/helper/UrlBuilder.java"
    },
    "Jsoup-109": {
        "buggy": "    void popStackToClose(String... elNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (inSorted(next.normalName(), elNames))\n                break;\n        }\n    }",
        "fix": "    void popStackToClose(String... elNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            stack.remove(pos);\n            if (inSorted(el.normalName(), elNames)) {\n                if (currentToken instanceof Token.EndTag)\n                    onNodeClosed(el, currentToken);\n                break;\n            }\n        }\n    }",
        "start": 425,
        "end": 435,
        "location": [
            427,
            429
        ],
        "fixed_class_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java"
    },
    "Jsoup-112": {
        "buggy": "    @Override\n    public Element empty() {\n        childNodes.clear();\n        return this;\n    }",
        "fix": "    @Override\n    public Element empty() {\n        // Detach each of the children -> parent links:\n        for (Node child : childNodes) {\n            child.parentNode = null;\n        }\n        childNodes.clear();\n        return this;\n    }",
        "start": 836,
        "end": 844,
        "location": [],
        "fixed_class_path": "src/main/java/org/jsoup/nodes/Element.java"
    },
    "Jsoup-114": {
        "buggy": "    private String consumeSubQuery() {\n        StringBuilder sq = StringUtil.borrowBuilder();\n        while (!tq.isEmpty()) {\n            if (tq.matches(\"(\"))\n                sq.append(\"(\").append(tq.chompBalanced('(', ')')).append(\")\");\n            else if (tq.matches(\"[\"))\n                sq.append(\"[\").append(tq.chompBalanced('[', ']')).append(\"]\");\n            else if (tq.matchesAny(Combinators))\n                if (sq.length() > 0)\n                    break;\n                else\n                    tq.consume();\n            else\n                sq.append(tq.consume());\n        }\n        return StringUtil.releaseBuilder(sq);\n    }",
        "fix": "    private String consumeSubQuery() {\n        StringBuilder sq = StringUtil.borrowBuilder();\n        boolean seenNonCombinator = false; // eat until we hit a combinator after eating something else\n        while (!tq.isEmpty()) {\n            if (tq.matches(\"(\"))\n                sq.append(\"(\").append(tq.chompBalanced('(', ')')).append(\")\");\n            else if (tq.matches(\"[\"))\n                sq.append(\"[\").append(tq.chompBalanced('[', ']')).append(\"]\");\n            else if (tq.matchesAny(Combinators))\n                if (seenNonCombinator)\n                    break;\n                else\n                    sq.append(tq.consume());\n            else {\n                seenNonCombinator = true;\n                sq.append(tq.consume());\n            }\n        }\n        return StringUtil.releaseBuilder(sq);\n    }",
        "start": 145,
        "end": 165,
        "location": [
            153,
            156,
            157
        ],
        "fixed_class_path": "src/main/java/org/jsoup/select/QueryParser.java"
    },
    "Jsoup-116": {
        "buggy": "    public void normalize() {\n        for (int i = 0; i < size; i++) {\n            if (!isInternalKey(keys[i]))\n                keys[i] = lowerCase(keys[i]);\n        }\n    }",
        "fix": "    public void normalize() {\n        for (int i = 0; i < size; i++) {\n            if (!isInternalKey(keys[i]))\n                keys[i] = lowerCase(keys[i]);\n        }\n\n        // if we are tracking attribute source ranges, normalize those keys also\n        //noinspection unchecked\n        Map<String, Range.AttributeRange> ranges = (Map<String, Range.AttributeRange>) userData(AttrRangeKey);\n        if (ranges != null) {\n            Object[] names = ranges.keySet().toArray(); // copy to array to avoid CMEs during put\n            for (Object name : names) {\n                String normal = lowerCase((String) name);\n                if (normal.equals(name)) continue;\n                if (ranges.containsKey(normal)) {\n                    ranges.remove(name); // dedupe now that we have normalized\n                } else {\n                    Range.AttributeRange range = ranges.remove(name);\n                    ranges.put(normal, range);\n                }\n            }\n        }\n    }",
        "start": 523,
        "end": 545,
        "location": [],
        "fixed_class_path": "src/main/java/org/jsoup/nodes/Attributes.java"
    },
    "Jsoup-118": {
        "buggy": "    void initialiseParse(Reader input, String baseUri, Parser parser) {\n        Validate.notNullParam(input, \"input\");\n        Validate.notNullParam(baseUri, \"baseUri\");\n        Validate.notNull(parser);\n\n        doc = new Document(parser.defaultNamespace(), baseUri);\n        doc.parser(parser);\n        this.parser = parser;\n        settings = parser.settings();\n        reader = new CharacterReader(input);\n        trackSourceRange = parser.isTrackPosition();\n        reader.trackNewlines(parser.isTrackErrors() || trackSourceRange); // when tracking errors or source ranges, enable newline tracking for better legibility\n        currentToken = null;\n        tokeniser = new Tokeniser(this);\n        stack = new ArrayList<>(32);\n        seenTags = new HashMap<>();\n        start = new Token.StartTag(this);\n        this.baseUri = baseUri;\n    }",
        "fix": "    void initialiseParse(Reader input, String baseUri, Parser parser) {\n        Validate.notNullParam(input, \"input\");\n        Validate.notNullParam(baseUri, \"baseUri\");\n        Validate.notNull(parser);\n\n        doc = new Document(parser.defaultNamespace(), baseUri);\n        doc.parser(parser);\n        this.parser = parser;\n        settings = parser.settings();\n        reader = new CharacterReader(input);\n        trackSourceRange = parser.isTrackPosition();\n        reader.trackNewlines(parser.isTrackErrors() || trackSourceRange); // when tracking errors or source ranges, enable newline tracking for better legibility\n        tokeniser = new Tokeniser(this);\n        stack = new ArrayList<>(32);\n        seenTags = new HashMap<>();\n        start = new Token.StartTag(this);\n        currentToken = start; // init current token to the virtual start token.\n        this.baseUri = baseUri;\n    }",
        "start": 38,
        "end": 57,
        "location": [
            50
        ],
        "fixed_class_path": "src/main/java/org/jsoup/parser/TreeBuilder.java"
    },
    "Jsoup-120": {
        "buggy": "    private String consumeSubQuery() {\n        StringBuilder sq = StringUtil.borrowBuilder();\n        boolean seenNonCombinator = false; // eat until we hit a combinator after eating something else\n        while (!tq.isEmpty()) {\n            if (tq.matches(\"(\"))\n                sq.append(\"(\").append(tq.chompBalanced('(', ')')).append(\")\");\n            else if (tq.matches(\"[\"))\n                sq.append(\"[\").append(tq.chompBalanced('[', ']')).append(\"]\");\n            else if (tq.matchesAny(Combinators))\n                if (seenNonCombinator)\n                    break;\n                else\n                    sq.append(tq.consume());\n            else {\n                seenNonCombinator = true;\n                sq.append(tq.consume());\n            }\n        }\n        return StringUtil.releaseBuilder(sq);\n    }",
        "fix": "    private String consumeSubQuery() {\n        StringBuilder sq = StringUtil.borrowBuilder();\n        boolean seenClause = false; // eat until we hit a combinator after eating something else\n        while (!tq.isEmpty()) {\n            if (tq.matchesAny(Combinators)) {\n                if (seenClause)\n                    break;\n                sq.append(tq.consume());\n                continue;\n            }\n            seenClause = true;\n            if (tq.matches(\"(\"))\n                sq.append(\"(\").append(tq.chompBalanced('(', ')')).append(\")\");\n            else if (tq.matches(\"[\"))\n                sq.append(\"[\").append(tq.chompBalanced('[', ']')).append(\"]\");\n            else\n                sq.append(tq.consume());\n        }\n        return StringUtil.releaseBuilder(sq);\n    }",
        "start": 145,
        "end": 165,
        "location": [
            147,
            153,
            154,
            155,
            156,
            157,
            158,
            159,
            161
        ],
        "fixed_class_path": "src/main/java/org/jsoup/select/QueryParser.java"
    },
    "Jsoup-121": {
        "buggy": "    @Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        if (out.syntax() == Document.OutputSettings.Syntax.xml) {\n            // In XML mode, output data nodes as CDATA, so can parse as XML\n            accum\n                .append(\"<![CDATA[\")\n                .append(getWholeData())\n                .append(\"]]>\");\n        } else {\n            // In HTML, data is not escaped in return from data nodes, so \" in script, style is plain\n            accum.append(getWholeData());\n        }\n    }",
        "fix": "    @Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        /* For XML output, escape the DataNode in a CData section. The data may contain pseudo-CData content if it was\n        parsed as HTML, so don't double up Cdata. Output in polygot HTML / XHTML / XML format. */\n        final String data = getWholeData();\n        if (out.syntax() == Document.OutputSettings.Syntax.xml && !data.contains(\"<![CDATA[\")) {\n            if (hasParent() && parentNode.normalName().equals(\"script\"))\n                accum.append(\"//<![CDATA[\\n\").append(data).append(\"\\n//]]>\");\n            else if (hasParent() && parentNode.normalName().equals(\"style\"))\n                accum.append(\"/*<![CDATA[*/\\n\").append(data).append(\"\\n/*]]>*/\");\n            else\n                accum.append(\"<![CDATA[\").append(data).append(\"]]>\");\n        } else {\n            // In HTML, data is not escaped in the output of data nodes, so < and & in script, style is OK\n            accum.append(getWholeData());\n        }\n    }",
        "start": 43,
        "end": 60,
        "location": [
            45,
            46,
            47,
            48,
            49,
            50,
            52
        ],
        "fixed_class_path": "src/main/java/org/jsoup/nodes/DataNode.java"
    },
    "Lang-600": {
        "buggy": "    public static Method getMatchingMethod(final Class<?> cls, final String methodName,\n            final Class<?>... parameterTypes) {\n        Objects.requireNonNull(cls, \"cls\");\n        Validate.notEmpty(methodName, \"methodName\");\n\n        final List<Method> methods = Stream.of(cls.getDeclaredMethods())\n                .filter(method -> method.getName().equals(methodName))\n                .collect(Collectors.toList());\n\n        ClassUtils.getAllSuperclasses(cls).stream()\n                .map(Class::getDeclaredMethods)\n                .flatMap(Stream::of)\n                .filter(method -> method.getName().equals(methodName))\n                .forEach(methods::add);\n\n        for (final Method method : methods) {\n            if (Arrays.deepEquals(method.getParameterTypes(), parameterTypes)) {\n                return method;\n            }\n        }\n\n        final TreeMap<Integer, List<Method>> candidates = new TreeMap<>();\n\n        methods.stream()\n                .filter(method -> ClassUtils.isAssignable(parameterTypes, method.getParameterTypes(), true))\n                .forEach(method -> {\n                    final int distance = distance(parameterTypes, method.getParameterTypes());\n                    final List<Method> candidatesAtDistance = candidates.computeIfAbsent(distance, k -> new ArrayList<>());\n                    candidatesAtDistance.add(method);\n                });\n\n        if (candidates.isEmpty()) {\n            return null;\n        }\n\n        final List<Method> bestCandidates = candidates.values().iterator().next();\n        if (bestCandidates.size() == 1) {\n            return bestCandidates.get(0);\n        }\n\n        throw new IllegalStateException(\n                String.format(\"Found multiple candidates for method %s on class %s : %s\",\n                        methodName + Stream.of(parameterTypes).map(String::valueOf).collect(Collectors.joining(\",\", \"(\", \")\")),\n                        cls.getName(),\n                        bestCandidates.stream().map(Method::toString).collect(Collectors.joining(\",\", \"[\", \"]\")))\n        );\n    }",
        "fix": "    public static Method getMatchingMethod(final Class<?> cls, final String methodName,\n            final Class<?>... parameterTypes) {\n        Objects.requireNonNull(cls, \"cls\");\n        Validate.notEmpty(methodName, \"methodName\");\n\n        final List<Method> methods = Stream.of(cls.getDeclaredMethods())\n                .filter(method -> method.getName().equals(methodName))\n                .collect(Collectors.toList());\n\n        ClassUtils.getAllSuperclasses(cls).stream()\n                .map(Class::getDeclaredMethods)\n                .flatMap(Stream::of)\n                .filter(method -> method.getName().equals(methodName))\n                .forEach(methods::add);\n\n        for (final Method method : methods) {\n            if (Arrays.deepEquals(method.getParameterTypes(), parameterTypes)) {\n                return method;\n            }\n        }\n\n        final TreeMap<Integer, List<Method>> candidates = new TreeMap<>();\n\n        methods.stream()\n                .filter(method -> ClassUtils.isAssignable(parameterTypes, method.getParameterTypes(), true))\n                .forEach(method -> {\n                    final int distance = distance(parameterTypes, method.getParameterTypes());\n                    final List<Method> candidatesAtDistance = candidates.computeIfAbsent(distance, k -> new ArrayList<>());\n                    candidatesAtDistance.add(method);\n                });\n\n        if (candidates.isEmpty()) {\n            return null;\n        }\n\n        final List<Method> bestCandidates = candidates.values().iterator().next();\n        if (bestCandidates.size() == 1 || !Objects.equals(bestCandidates.get(0).getDeclaringClass(),\n                bestCandidates.get(1).getDeclaringClass())) {\n            return bestCandidates.get(0);\n        }\n\n        throw new IllegalStateException(\n                String.format(\"Found multiple candidates for method %s on class %s : %s\",\n                        methodName + Stream.of(parameterTypes).map(String::valueOf).collect(Collectors.joining(\",\", \"(\", \")\")),\n                        cls.getName(),\n                        bestCandidates.stream().map(Method::toString).collect(Collectors.joining(\",\", \"[\", \"]\")))\n        );\n    }",
        "start": 718,
        "end": 765,
        "location": [
            754
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/lang3/reflect/MethodUtils.java"
    },
    "Lang-606": {
        "buggy": "    public static Class<?> getRawType(final Type type, final Type assigningType) {\n        if (type instanceof Class<?>) {\n            // it is raw, no problem\n            return (Class<?>) type;\n        }\n\n        if (type instanceof ParameterizedType) {\n            // simple enough to get the raw type of a ParameterizedType\n            return getRawType((ParameterizedType) type);\n        }\n\n        if (type instanceof TypeVariable<?>) {\n            if (assigningType == null) {\n                return null;\n            }\n\n            // get the entity declaring this type variable\n            final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration();\n\n            // can't get the raw type of a method- or constructor-declared type\n            // variable\n            if (!(genericDeclaration instanceof Class<?>)) {\n                return null;\n            }\n\n            // get the type arguments for the declaring class/interface based\n            // on the enclosing type\n            final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType,\n                    (Class<?>) genericDeclaration);\n\n            // enclosingType has to be a subclass (or subinterface) of the\n            // declaring type\n            if (typeVarAssigns == null) {\n                return null;\n            }\n\n            // get the argument assigned to this type variable\n            final Type typeArgument = typeVarAssigns.get(type);\n\n            if (typeArgument == null) {\n                return null;\n            }\n\n            // get the argument for this type variable\n            return getRawType(typeArgument, assigningType);\n        }\n\n        if (type instanceof GenericArrayType) {\n            // get raw component type\n            final Class<?> rawComponentType = getRawType(((GenericArrayType) type)\n                    .getGenericComponentType(), assigningType);\n\n            // create array type from raw component type and return its class\n            return Array.newInstance(rawComponentType, 0).getClass();\n        }\n\n        // (hand-waving) this is not the method you're looking for\n        if (type instanceof WildcardType) {\n            return null;\n        }\n\n        throw new IllegalArgumentException(\"unknown type: \" + type);\n    }",
        "fix": "    public static Class<?> getRawType(final Type type, final Type assigningType) {\n        if (type instanceof Class<?>) {\n            // it is raw, no problem\n            return (Class<?>) type;\n        }\n\n        if (type instanceof ParameterizedType) {\n            // simple enough to get the raw type of a ParameterizedType\n            return getRawType((ParameterizedType) type);\n        }\n\n        if (type instanceof TypeVariable<?>) {\n            if (assigningType == null) {\n                return null;\n            }\n\n            // get the entity declaring this type variable\n            final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration();\n\n            // can't get the raw type of a method- or constructor-declared type\n            // variable\n            if (!(genericDeclaration instanceof Class<?>)) {\n                return null;\n            }\n\n            // get the type arguments for the declaring class/interface based\n            // on the enclosing type\n            final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType,\n                    (Class<?>) genericDeclaration);\n\n            // enclosingType has to be a subclass (or subinterface) of the\n            // declaring type\n            if (typeVarAssigns == null) {\n                return null;\n            }\n\n            // get the argument assigned to this type variable\n            final Type typeArgument = typeVarAssigns.get(type);\n\n            if (typeArgument == null) {\n                return null;\n            }\n\n            // get the argument for this type variable\n            return getRawType(typeArgument, assigningType);\n        }\n\n        if (type instanceof GenericArrayType) {\n            // get raw component type\n            final Class<?> rawComponentType = getRawType(((GenericArrayType) type)\n                    .getGenericComponentType(), assigningType);\n\n            // create array type from raw component type and return its class\n            return rawComponentType != null ? Array.newInstance(rawComponentType, 0).getClass() : null;\n        }\n\n        // (hand-waving) this is not the method you're looking for\n        if (type instanceof WildcardType) {\n            return null;\n        }\n\n        throw new IllegalArgumentException(\"unknown type: \" + type);\n    }",
        "start": 752,
        "end": 814,
        "location": [
            805
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java"
    },
    "Lang-609": {
        "buggy": "    protected void appendFieldsIn(final Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        // The elements in the returned array are not sorted and are not in any particular order.\n        final Field[] fields = ArraySorter.sort(clazz.getDeclaredFields(), Comparator.comparing(Field::getName));\n        AccessibleObject.setAccessible(fields, true);\n        for (final Field field : fields) {\n            final String fieldName = field.getName();\n            if (this.accept(field)) {\n                // Warning: Field.get(Object) creates wrappers objects for primitive types.\n                final Object fieldValue = Reflection.getUnchecked(field, getObject());\n                if (!excludeNullValues || fieldValue != null) {\n                    this.append(fieldName, fieldValue, !field.isAnnotationPresent(ToStringSummary.class));\n                }\n            }\n        }\n    }",
        "fix": "    protected void appendFieldsIn(final Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        // The elements in the returned array are not sorted and are not in any particular order.\n        final Field[] fields = ArraySorter.sort(clazz.getDeclaredFields(), Comparator.comparing(Field::getName));\n        AccessibleObject.setAccessible(fields, true);\n        for (final Field field : fields) {\n            final String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    final Object fieldValue = this.getValue(field);\n                    if (!excludeNullValues || fieldValue != null) {\n                        this.append(fieldName, fieldValue, !field.isAnnotationPresent(ToStringSummary.class));\n                    }\n                } catch (final IllegalAccessException e) {\n                    // this can't happen. Would get a Security exception instead throw a runtime exception in case the\n                    // impossible happens.\n                    throw new IllegalStateException(e);\n                }\n            }\n        }\n    }",
        "start": 649,
        "end": 674,
        "location": [
            660,
            661,
            662,
            663
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java"
    },
    "Lang-611": {
        "buggy": "    public static Number createNumber(final String str) {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Need to deal with all possible hex prefixes here\n        final String[] hexPrefixes = {\"0x\", \"0X\", \"#\"};\n        final int length = str.length();\n        final int offset = str.charAt(0) == '+' || str.charAt(0) == '-' ? 1 : 0;\n        int pfxLen = 0;\n        for (final String pfx : hexPrefixes) {\n            if (str.startsWith(pfx, offset)) {\n                pfxLen += pfx.length() + offset;\n                break;\n            }\n        }\n        if (pfxLen > 0) { // we have a hex number\n            char firstSigDigit = 0; // strip leading zeroes\n            for (int i = pfxLen; i < length; i++) {\n                firstSigDigit = str.charAt(i);\n                if (firstSigDigit != '0') {\n                    break;\n                }\n                pfxLen++;\n            }\n            final int hexDigits = length - pfxLen;\n            if (hexDigits > 16 || hexDigits == 16 && firstSigDigit > '7') { // too many for Long\n                return createBigInteger(str);\n            }\n            if (hexDigits > 8 || hexDigits == 8 && firstSigDigit > '7') { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }\n        final char lastChar = str.charAt(length - 1);\n        final String mant;\n        final String dec;\n        final String exp;\n        final int decPos = str.indexOf('.');\n        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n        // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n\n        // Detect if the return type has been requested\n        final boolean requestType = !Character.isDigit(lastChar) && lastChar != '.';\n        if (decPos > -1) { // there is a decimal point\n            if (expPos > -1) { // there is an exponent\n                if (expPos < decPos || expPos > length) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                // No exponent, but there may be a type character to remove\n                dec = str.substring(decPos + 1, requestType ? length - 1 : length);\n            }\n            mant = getMantissa(str, decPos);\n        } else {\n            if (expPos > -1) {\n                if (expPos > length) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = getMantissa(str, expPos);\n            } else {\n                // No decimal, no exponent, but there may be a type character to remove\n                mant = getMantissa(str, requestType ? length - 1 : length);\n            }\n            dec = null;\n        }\n        if (requestType) {\n            if (expPos > -1 && expPos < length - 1) {\n                exp = str.substring(expPos + 1, length - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type.\n            final String numeric = str.substring(0, length - 1);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (!numeric.isEmpty() && numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (final NumberFormatException ignored) {\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        final Float f = createFloat(str);\n                        if (!(f.isInfinite() || f.floatValue() == 0.0F && !isZero(mant, dec))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (final NumberFormatException ignored) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        final Double d = createDouble(str);\n                        if (!(d.isInfinite() || d.doubleValue() == 0.0D && !isZero(mant, dec))) {\n                            return d;\n                        }\n                    } catch (final NumberFormatException ignored) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (final NumberFormatException ignored) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        }\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (expPos > -1 && expPos < length - 1) {\n            exp = str.substring(expPos + 1);\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) { // no decimal point and no exponent\n            //Must be an Integer, Long, Biginteger\n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException ignored) {\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (final NumberFormatException ignored) {\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n        }\n\n        //Must be a Float, Double, BigDecimal\n        try {\n            final Float f = createFloat(str);\n            final Double d = createDouble(str);\n            if (!f.isInfinite()\n                    && !(f.floatValue() == 0.0F && !isZero(mant, dec))\n                    && f.toString().equals(d.toString())) {\n                return f;\n            }\n            if (!d.isInfinite() && !(d.doubleValue() == 0.0D && !isZero(mant, dec))) {\n                final BigDecimal b = createBigDecimal(str);\n                if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) == 0) {\n                    return d;\n                }\n                return b;\n            }\n        } catch (final NumberFormatException ignored) {\n            // ignore the bad number\n        }\n        return createBigDecimal(str);\n    }",
        "fix": "    public static Number createNumber(final String str) {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Need to deal with all possible hex prefixes here\n        final String[] hexPrefixes = {\"0x\", \"0X\", \"#\"};\n        final int length = str.length();\n        final int offset = str.charAt(0) == '+' || str.charAt(0) == '-' ? 1 : 0;\n        int pfxLen = 0;\n        for (final String pfx : hexPrefixes) {\n            if (str.startsWith(pfx, offset)) {\n                pfxLen += pfx.length() + offset;\n                break;\n            }\n        }\n        if (pfxLen > 0) { // we have a hex number\n            char firstSigDigit = 0; // strip leading zeroes\n            for (int i = pfxLen; i < length; i++) {\n                firstSigDigit = str.charAt(i);\n                if (firstSigDigit != '0') {\n                    break;\n                }\n                pfxLen++;\n            }\n            final int hexDigits = length - pfxLen;\n            if (hexDigits > 16 || hexDigits == 16 && firstSigDigit > '7') { // too many for Long\n                return createBigInteger(str);\n            }\n            if (hexDigits > 8 || hexDigits == 8 && firstSigDigit > '7') { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }\n        final char lastChar = str.charAt(length - 1);\n        final String mant;\n        final String dec;\n        final String exp;\n        final int decPos = str.indexOf('.');\n        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n        // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n\n        // Detect if the return type has been requested\n        final boolean requestType = !Character.isDigit(lastChar) && lastChar != '.';\n        if (decPos > -1) { // there is a decimal point\n            if (expPos > -1) { // there is an exponent\n                if (expPos <= decPos || expPos > length) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                // No exponent, but there may be a type character to remove\n                dec = str.substring(decPos + 1, requestType ? length - 1 : length);\n            }\n            mant = getMantissa(str, decPos);\n        } else {\n            if (expPos > -1) {\n                if (expPos > length) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = getMantissa(str, expPos);\n            } else {\n                // No decimal, no exponent, but there may be a type character to remove\n                mant = getMantissa(str, requestType ? length - 1 : length);\n            }\n            dec = null;\n        }\n        if (requestType) {\n            if (expPos > -1 && expPos < length - 1) {\n                exp = str.substring(expPos + 1, length - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type.\n            final String numeric = str.substring(0, length - 1);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (!numeric.isEmpty() && numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (final NumberFormatException ignored) {\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        final Float f = createFloat(str);\n                        if (!(f.isInfinite() || f.floatValue() == 0.0F && !isZero(mant, dec))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (final NumberFormatException ignored) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        final Double d = createDouble(str);\n                        if (!(d.isInfinite() || d.doubleValue() == 0.0D && !isZero(mant, dec))) {\n                            return d;\n                        }\n                    } catch (final NumberFormatException ignored) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (final NumberFormatException ignored) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        }\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (expPos > -1 && expPos < length - 1) {\n            exp = str.substring(expPos + 1);\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) { // no decimal point and no exponent\n            //Must be an Integer, Long, Biginteger\n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException ignored) {\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (final NumberFormatException ignored) {\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n        }\n\n        //Must be a Float, Double, BigDecimal\n        try {\n            final Float f = createFloat(str);\n            final Double d = createDouble(str);\n            if (!f.isInfinite()\n                    && !(f.floatValue() == 0.0F && !isZero(mant, dec))\n                    && f.toString().equals(d.toString())) {\n                return f;\n            }\n            if (!d.isInfinite() && !(d.doubleValue() == 0.0D && !isZero(mant, dec))) {\n                final BigDecimal b = createBigDecimal(str);\n                if (b.compareTo(BigDecimal.valueOf(d.doubleValue())) == 0) {\n                    return d;\n                }\n                return b;\n            }\n        } catch (final NumberFormatException ignored) {\n            // ignore the bad number\n        }\n        return createBigDecimal(str);\n    }",
        "start": 315,
        "end": 485,
        "location": [
            364
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java"
    },
    "Lang-613": {
        "buggy": "    @SuppressWarnings(\"resource\") // inputStream is managed by the caller\n    public static <T> T deserialize(final InputStream inputStream) {\n        Objects.requireNonNull(inputStream, \"inputStream\");\n        try (ObjectInputStream in = new ObjectInputStream(inputStream)) {\n            @SuppressWarnings(\"unchecked\")\n            final T obj = (T) in.readObject();\n            return obj;\n        } catch (final ClassNotFoundException | IOException ex) {\n            throw new SerializationException(ex);\n        }\n    }",
        "fix": "    @SuppressWarnings(\"resource\") // inputStream is managed by the caller\n    public static <T> T deserialize(final InputStream inputStream) {\n        Objects.requireNonNull(inputStream, \"inputStream\");\n        try (ObjectInputStream in = new ObjectInputStream(inputStream)) {\n            @SuppressWarnings(\"unchecked\")\n            final T obj = (T) in.readObject();\n            return obj;\n        } catch (final ClassNotFoundException | IOException | NegativeArraySizeException ex) {\n            throw new SerializationException(ex);\n        }\n    }",
        "start": 203,
        "end": 213,
        "location": [
            210
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/lang3/SerializationUtils.java"
    },
    "Lang-614": {
        "buggy": "    private static String getMantissa(final String str, final int stopPos) {\n        final char firstChar = str.charAt(0);\n        final boolean hasSign = firstChar == '-' || firstChar == '+';\n\n        return hasSign ? str.substring(1, stopPos) : str.substring(0, stopPos);\n    }",
        "fix": "    private static String getMantissa(final String str, final int stopPos) {\n         final char firstChar = str.charAt(0);\n         final boolean hasSign = firstChar == '-' || firstChar == '+';\n         final int length = str.length();\n         if (length <= (hasSign ? 1 : 0) || length < stopPos) {\n             throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n         return hasSign ? str.substring(1, stopPos) : str.substring(0, stopPos);\n    }",
        "start": 497,
        "end": 505,
        "location": [
            498,
            499,
            501
        ],
        "fixed_class_path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java"
    }
}